{
    "version": "https://jsonfeed.org/version/1",
    "title": "寻找未曾见过的你 • All posts by \"c\" category",
    "description": "吉兆要出现三次，幸运才会降临；谢幕时应当三次鞠躬；而在风来人的剑斗剧中，胜负的对手也有三名。",
    "home_page_url": "https://ashgen.gitee.io",
    "items": [
        {
            "id": "https://ashgen.gitee.io/2023/03/17/C/C++%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/",
            "url": "https://ashgen.gitee.io/2023/03/17/C/C++%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/",
            "title": "C++实用函数",
            "date_published": "2023-03-17T08:18:25.000Z",
            "content_html": "<h1 id=\"strtok\"><a class=\"markdownIt-Anchor\" href=\"#strtok\">#</a> strtok()</h1>\n<h2 id=\"描述\"><a class=\"markdownIt-Anchor\" href=\"#描述\">#</a> 描述</h2>\n<p>C 库函数 <strong>char *strtok(char *str, const char *delim)</strong> 分解字符串 <strong>str</strong> 为一组字符串，<strong>delim</strong> 为分隔符。</p>\n<h2 id=\"声明\"><a class=\"markdownIt-Anchor\" href=\"#声明\">#</a> 声明</h2>\n<p>下面是 strtok () 函数的声明。</p>\n<pre><code>char *strtok(char *str, const char *delim)\n</code></pre>\n<h2 id=\"参数\"><a class=\"markdownIt-Anchor\" href=\"#参数\">#</a> 参数</h2>\n<ul>\n<li><strong>str</strong> – 要被分解成一组小字符串的字符串。</li>\n<li><strong>delim</strong> – 包含分隔符的 C 字符串。</li>\n</ul>\n<h2 id=\"返回值\"><a class=\"markdownIt-Anchor\" href=\"#返回值\">#</a> 返回值</h2>\n<p>该函数返回被分解的第一个子字符串，如果没有可检索的字符串，则返回一个空指针。</p>\n<h2 id=\"实例\"><a class=\"markdownIt-Anchor\" href=\"#实例\">#</a> 实例</h2>\n<p>下面的实例演示了 strtok () 函数的用法。</p>\n<h2 id=\"实例-2\"><a class=\"markdownIt-Anchor\" href=\"#实例-2\">#</a> 实例</h2>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h></span> </span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span>  </span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>   </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">char</span> str<span class=\"token punctuation\">[</span><span class=\"token number\">80</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"This is - www.runoob.com - website\"</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> s<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"-\"</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>token<span class=\"token punctuation\">;</span>      <span class=\"token comment\">/* 获取第一个子字符串 */</span>   </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    token <span class=\"token operator\">=</span> <span class=\"token function\">strtok</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">/* 继续获取其他的子字符串 */</span>   </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span> token <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>      </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\"%s\\n\"</span><span class=\"token punctuation\">,</span> token <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>          </pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        token <span class=\"token operator\">=</span> <span class=\"token function\">strtok</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span>      </pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>让我们编译并运行上面的程序，这将产生以下结果：</p>\n<pre><code>This is \n www.runoob.com \n website\n</code></pre>\n<h1 id=\"string中c_str-data-copypn函数的用法\"><a class=\"markdownIt-Anchor\" href=\"#string中c_str-data-copypn函数的用法\">#</a> string 中 c_str ()、data ()、copy (p,n) 函数的用法</h1>\n<p>标准库的 string 类提供了 3 个成员函数来从一个 string 得到 c 类型的字符数组：c_str ()、data ()、copy (p,n)。</p>\n<h2 id=\"c_str生成一个const-char指针指向以空字符终止的数组\"><a class=\"markdownIt-Anchor\" href=\"#c_str生成一个const-char指针指向以空字符终止的数组\">#</a> c_str ()：生成一个 const char * 指针，指向以空字符终止的数组。</h2>\n<p>①这个数组的数据是临时的，当有一个改变这些数据的成员函数被调用后，其中的数据就会失效。因此要么现用先转换，要么把它的数据复制到用户自己可以管理的内存中。注意。看下例：</p>\n<pre><code class=\"language-c++\">const char* c;\nstring s=&quot;1234&quot;;\nc = s.c_str(); \ncout&lt;&lt;c&lt;&lt;endl; //输出：1234\ns=&quot;abcd&quot;;\ncout&lt;&lt;c&lt;&lt;endl; //输出：abcd\n</code></pre>\n<p>上面如果继续用 c 指针的话，导致的错误将是不可想象的。就如：1234 变为 abcd</p>\n<p>其实上面的 c = s.c_str (); 不是一个好习惯。既然 c 指针指向的内容容易失效，我们就应该按照上面的方法，那怎么把数据复制出来呢？这就要用到 strcpy 等函数（推荐）。</p>\n<pre><code class=\"language-c++\">//const char* c; //①\n//char* c;       //②\n//char c[20]; \nchar* c=new char[20];\nstring s=&quot;1234&quot;;\n//c = s.c_str(); \nstrcpy(c,s.c_str());\ncout&lt;&lt;c&lt;&lt;endl; //输出：1234\ns=&quot;abcd&quot;;\ncout&lt;&lt;c&lt;&lt;endl; //输出：1234\n</code></pre>\n<p>注意：不能再像上面一样①所示了，const 还怎么向里面写入值啊；也不能②所示，使用了未初始化的局部变量 “c”，运行会出错的 。</p>\n<p>② c_str () 返回一个客户程序可读不可改的指向字符数组的指针，不需要手动释放或删除这个指针。</p>\n<p><strong>data (): 与 c_str () 类似，但是返回的数组不以空字符终止。</strong></p>\n<h1 id=\"sort\"><a class=\"markdownIt-Anchor\" href=\"#sort\">#</a> sort()</h1>\n<p>对指定范围内元素进行快速排序</p>\n<p>sort 是 STL 自带的系统函数，它的格式是：</p>\n<p>void sort (要排序元素的起始地址，要排序元素的结束地址，比较函数)；</p>\n<p>这里可以省略比较函数，他是默认从小到大排序的（升序排序）</p>\n<pre><code class=\"language-c++\">#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n&#123;\n\tint a[]=&#123;3,5,2,6,9,3,5&#125;;\n\tsort(a,a+7);//7是数组的元素个数，这里a为数组的开头，a+7就等于排序到数组的第七个元素\n\tfor(int i=0;i&lt;6;i++)\n\t\tcout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;\n&#125;\n</code></pre>\n<p>输出:</p>\n<p>2 3 3 5 5 6</p>\n<p>void sort (要排序元素的起始地址，要排序元素的结束地址，比较函数)；</p>\n<p>这个比较函数的作用就是可以自定义排序方式，比如降序排序。</p>\n<p>定义：bool cmp (int x,int y)…，如果返回 True 那么 x 就排在 y 前面。</p>\n<pre><code class=\"language-c++\">#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nbool cmp(int x,int y)\n&#123;\n\tif(x&gt;y)return true;//降序\n\treturn false;\n&#125;\nint main()\n&#123;\n\tint a[]=&#123;3,5,2,6,9,3,5&#125;;\n\tsort(a,a+7,cmp);//7是数组的元素个数\n\tfor(int i=0;i&lt;6;i++)\n\t\tcout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;\n&#125;\n</code></pre>\n<p>输出：</p>\n<p>9 6 5 5 3 3</p>\n<h1 id=\"map\"><a class=\"markdownIt-Anchor\" href=\"#map\">#</a> Map</h1>\n<p>map 是 STL 的一个关联容器，它提供一对一的 hash。</p>\n<p>第一个可以称为关键字 (key)，每个关键字只能在 map 中出现一次；<br>\n第二个可能称为该关键字的值 (value)；<br>\n定义：<br>\nmap &lt;类型，类型&gt; m;<br>\n 举个栗子:<br>\n 记录每个人的名字的对应的爱好，张三喜欢吃汉堡：</p>\n<pre><code class=\"language-c++\">#include&lt;map&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n&#123;\n\tmap&lt;string,string&gt; m;\n\tm[&quot;张三&quot;]=&quot;吃汉堡&quot;;\n\tcout&lt;&lt;&quot;张三: &quot;&lt;&lt;m[&quot;张三&quot;]; \n&#125;\n</code></pre>\n<p>输出：</p>\n<p>张三：吃汉堡</p>\n<h1 id=\"stack栈\"><a class=\"markdownIt-Anchor\" href=\"#stack栈\">#</a> stack (栈)</h1>\n<p>头文件:</p>\n<p>#include<stack><br>\nstack 好像还有个翻译叫 “咸鱼”… 嘿嘿。</stack></p>\n<p>栈的介绍：<br>\n栈就像一个盒子，可以放入或去除元素，但是个人类都知道，要把盒子底下的东西取出来，就必须先取出他上面的东西。</p>\n<p>假如我们把 1、2、3、4、5 按顺序分别入栈：</p>\n<p>栈的定义：<br>\nstack &lt;类型 (可以不写)&gt; st;<br>\n 或者 stack st;<br>\n 很 easy 是不？</p>\n<p>栈的成员函数：<br>\n.empty ()\t判断栈是否为空，空则返回 true<br>\n.pop ()\t移除栈顶元素<br>\n.push (啥啥啥)\t在栈顶增加元素<br>\n.size ()\t返回栈中元素数目<br>\n.top ()\t返回栈顶元素<br>\n.empty ()  判断栈是否为空。</p>\n<pre><code class=\"language-c++\">stack st;\nif(st.empty())//如果是空那么执行下面代码\n    ......\n</code></pre>\n<p>.push (啥啥啥), 在栈顶增加元素。</p>\n<p>.top ()，返回栈顶元素，记住是返回，要单独输出。</p>\n<pre><code class=\"language-c++\">#include&lt;stack&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nstack&lt;int&gt; st;\nint main()&#123;\n    st.push(5418);\n    cout&lt;&lt;st.top();//输出栈顶元素\n    return 0;\n\n&#125;\n</code></pre>\n<p>输出 5418。</p>\n<p>​</p>\n<p>.size (), 返回栈中元素数目。</p>\n<pre><code class=\"language-c++\">#include&lt;stack&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nstack&lt;int&gt; st;\nint main()&#123;\n    st.push(5418);\n    cout&lt;&lt;st.size();\n    return 0;\n&#125;\n</code></pre>\n<p>输出 1</p>\n<p>.pop ()，移除栈顶元素：</p>\n<pre><code class=\"language-c++\">#include&lt;stack&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nstack&lt;int&gt; st;\nint main()&#123;\n    \n\n    st.push(1452);\n    st.push(5418);\n    st.pop();\n    cout&lt;&lt;st.top();\n    \n    return 0;\n\n&#125;\n</code></pre>\n<p>输出 1452。</p>\n<p>简单不？</p>\n<h1 id=\"二分查找\"><a class=\"markdownIt-Anchor\" href=\"#二分查找\">#</a> 二分查找</h1>\n<p>头文件：</p>\n<pre><code class=\"language-c++\">#include &lt;algorithm&gt;\n</code></pre>\n<p>美妙的函数：</p>\n<h2 id=\"1lower_bound函数\"><a class=\"markdownIt-Anchor\" href=\"#1lower_bound函数\">#</a> 1.lower_bound 函数</h2>\n<p>对于有序容器，有序容器，有序容器（重要的事情说三遍）快速二分查找出第一个大于等于</p>\n<p>指定数的位置（下标），如果没有找到，返回最后一个数据后面的位置。</p>\n<p>对于数组，通常的格式为：</p>\n<p>查找的数组下标 = lower_bound (数组要查找的开始位置，数组要查找的结束位置后面，要找的数) – 数组开始位置 (一般写数组名);</p>\n<p>比如：</p>\n<pre><code class=\"language-c++\">#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\n\nusing namespace std;\n\nint main() &#123;\n\n    int a[5] = &#123; 1,2,3,3,8 &#125;;\n     \n    //从 a 数组中找到第一个不小于   3 的元素\n     \n    int   index = lower_bound(a, a + 5, 3)-a;//查找的数组下标 = lower_bound(数组要查找的开始位置，数组要查找的结束位置后面，要找的数) – 数组开始位置;\n     \n    if   (index==5 ) cout &lt;&lt; &quot; not found! &quot;;//index=5，也就是数组末尾的位置。\n    else  cout &lt;&lt; index;\n     \n    return   0;\n\n&#125;\n</code></pre>\n<p>输出 2。</p>\n<h2 id=\"2upper_bound函数\"><a class=\"markdownIt-Anchor\" href=\"#2upper_bound函数\">#</a> 2.upper_bound 函数</h2>\n<p>有一个类似 lower_bound 的函数 upper_bound, 快速二分查找出第一个大于指定数的位置（下</p>\n<p>标），如果没有找到，返回最后一个数据后面的位置。</p>\n<p>举个栗子，啊… 快没栗子了。(っ °Д °;) っ</p>\n<pre><code class=\"language-c++\">#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\n\nusing namespace std;\n\nint main() &#123;\n\n    int a[5] = &#123; 1,2,3,3,8 &#125;;\n    //从 a 数组中找到第一个大于 3 的元素\n     \n    int   index = upper_bound(a, a + 5, 3)-a;\n     \n    if   (index==5 ) cout &lt;&lt; &quot; not found! &quot;;\n    else cout &lt;&lt; index;\n     \n    return   0;\n\n&#125;\n</code></pre>\n<p>输出 4.</p>\n<h2 id=\"3binary_search查找数组内某个元素是否出现\"><a class=\"markdownIt-Anchor\" href=\"#3binary_search查找数组内某个元素是否出现\">#</a> 3.binary_search：查找数组内某个元素是否出现。</h2>\n<p>void binary_search (数组首地址，结束地址，要查找的数)</p>\n<p>返回值为 bool 类型，找到了返回 true。</p>\n",
            "tags": [
                "XXX"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/03/04/C/C++%E9%97%AE%E9%A2%98/",
            "url": "https://ashgen.gitee.io/2023/03/04/C/C++%E9%97%AE%E9%A2%98/",
            "title": "C++问题",
            "date_published": "2023-03-04T03:24:00.000Z",
            "content_html": "<p>使用范围 for 语句时，变量需定义在内部</p>\n<pre><code class=\"language-c++\">for(auto c : line)\n\t\tc=toupper(c);\n</code></pre>\n<h1 id=\"字符串转整数\"><a class=\"markdownIt-Anchor\" href=\"#字符串转整数\">#</a> 字符串转整数</h1>\n<pre><code class=\"language-C++\">string s=&quot;123&quot;;\nstringstream ss;\nint x=0;\nss&lt;&lt;s;\nss&gt;&gt;x;\ncout&lt;&lt;x+1&lt;&lt;endl;\n</code></pre>\n<h1 id=\"整数转字符串\"><a class=\"markdownIt-Anchor\" href=\"#整数转字符串\">#</a> 整数转字符串</h1>\n<pre><code class=\"language-c++\">int s=123;\nstringstream ss;\nstring x;\nss&lt;&lt;s;\nss&gt;&gt;x;\ncout&lt;&lt;x&lt;&lt;endl;\nreturn 0;\n</code></pre>\n",
            "tags": [
                "细节问题"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/02/28/C/C%E8%AF%AD%E8%A8%80%E9%97%AE%E9%A2%98/",
            "url": "https://ashgen.gitee.io/2023/02/28/C/C%E8%AF%AD%E8%A8%80%E9%97%AE%E9%A2%98/",
            "title": "C语言问题",
            "date_published": "2023-02-28T09:00:00.000Z",
            "content_html": "<h1 id=\"数组名取地址a\"><a class=\"markdownIt-Anchor\" href=\"#数组名取地址a\">#</a> 数组名取地址 &amp; a</h1>\n<p>a 是一个数组名，对于一个普通的变量 b，&amp;b 是指用取地址符号取得变量 b 的存放地址；a 在内存中没有分配空间，只对数组 a 的各个元素分配了存储空间，此处数组名字 a 显然不是普通的变量，&amp;a 也不代表所取 a 的存储地址。</p>\n<p><strong>&amp;a 在数值上等于 &amp; a [0]，也等于 a。<strong>此时，&amp;a 数值上等于整个数组的起始位置地址，含义上代表整个数组所占内存的大小，因为它的</strong>进阶单位是整个数组的字节长度</strong>，（&amp;a + 1）等于的是数组结束之后的下一段的起始位置地址。</p>\n",
            "tags": [
                "细节问题"
            ]
        }
    ]
}