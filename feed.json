{
    "version": "https://jsonfeed.org/version/1",
    "title": "寻找未曾见过的你",
    "description": "吉兆要出现三次，幸运才会降临；谢幕时应当三次鞠躬；而在风来人的剑斗剧中，胜负的对手也有三名。",
    "home_page_url": "https://ashgen.gitee.io",
    "items": [
        {
            "id": "https://ashgen.gitee.io/2023/03/26/java/JDK%E4%B8%8EJRE%E7%9A%84%E5%8C%BA%E5%88%AB/",
            "url": "https://ashgen.gitee.io/2023/03/26/java/JDK%E4%B8%8EJRE%E7%9A%84%E5%8C%BA%E5%88%AB/",
            "title": "JDK与JRE的区别",
            "date_published": "2023-03-26T12:46:25.000Z",
            "content_html": "<p>JDK 和 JRE 是 Java 开发和运行工具，其中 JDK 包含了 JRE，但是 JRE 是可以独立安装的，它们在 Java 开发和运行的时候起到不同的作用</p>\n<h1 id=\"1jdk\"><a class=\"markdownIt-Anchor\" href=\"#1jdk\">#</a> 1.JDK</h1>\n<p>​    JDK 是 Java Development Kit 的缩写，是 Java 的开发工具包，主要包含了各种类库和工具，当然也包含了另外一个 JRE.。那么为什么要包含另外一个 JRE 呢？而且 &lt;JDK 安装目录&gt;/JRE/bin 目录下，包含有 server 一个文件夹～包含一个 jvm.dll，这说明 JDK 提供了一个虚拟机。</p>\n<p>​    另外，JDK 的 bin 目录下有各种 Java 程序需要用到的命令，与 JRE 的 bin 目录最明显的区别就是 JDK 文件下才有 javac，这一点很好理解，因为 JRE 只是一个运行环境而已，与开发无关。正因为如此，具备开发功能的 JDK 所包含的 JRE 下才会同时有 server 的 JVM，而仅仅作为运行环境的 JRE 下，只需要 server 的 jvm.dll 就够了。</p>\n<p>注意：JDK 所提供的运行环境和工具度需要进行环境变量的配置以后，才能使用，最主要的配置就是把 &lt;JDK 安装目录&gt;/bin 目录设置为 Path 环境变量值的一部分。</p>\n<h1 id=\"2jre\"><a class=\"markdownIt-Anchor\" href=\"#2jre\">#</a> 2.JRE</h1>\n<p>​    JRE 是 Java Runtime Environment 的缩写，是 Java 程序的运行环境。既然是运行，当然要包含 JVM，也就是所谓的 Java 虚拟机，还有所以的 Java 类库的 class 文件，都在 lib 目录下，并且都打包成了 jar。</p>\n<p>至于在 Windows 上的虚拟机是哪个文件呢？就是 &lt;JRE 安装目录&gt;/bin/server 中的 jvm.dll。</p>\n<p><img data-src=\"https://img-blog.csdn.net/20160807174832320?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"img\"></p>\n<p>另外，安装 JRE 的时候安装程序会自动把 JRE 的 java.exe 添加到了系统变量中。系统变量 Path 的最前面有 % SystemRoot% system32;% SystemRoot%; 这样的配置，那样到 Windows/system32 目录下 main 去看看，会发现一个 java.exe 文件。这样就无需配置环境变量，也可以运行 Java 程序了。</p>\n<h1 id=\"3jdk与jre的区别\"><a class=\"markdownIt-Anchor\" href=\"#3jdk与jre的区别\">#</a> 3.JDK 与 JRE 的区别</h1>\n<p>​    JDK 是 Java 的开发工具，它不仅提供了 Java 程序运行所需的 JRE，还提供了一系列的编译，运行等工具，如 javac，java，javaw 等。JRE 只是 Java 程序的运行环境，它最核心的内容就是 JVM（Java 虚拟机）及核心类库。</p>\n<h1 id=\"4tomcat和jdk是什么关系\"><a class=\"markdownIt-Anchor\" href=\"#4tomcat和jdk是什么关系\">#</a> 4.Tomcat 和 JDK 是什么关系</h1>\n<p>tomcat 是 java 的 web 项目运行容器之一；<br>\njdk 是 java 运行环境。也就是说 java 没有 jdk 肯定是没法编译运行的。<br>\njava 运行必须依赖于 jdk 环境，但是不一定要用 tomcat 容器，如 WebLogic、WebSphere 等都是可以的。</p>\n",
            "tags": [
                "java"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/03/26/java/spring%E7%AE%80%E4%BB%8B/",
            "url": "https://ashgen.gitee.io/2023/03/26/java/spring%E7%AE%80%E4%BB%8B/",
            "title": "Spring简介",
            "date_published": "2023-03-26T05:46:25.000Z",
            "content_html": "<h1 id=\"spring简介\"><a class=\"markdownIt-Anchor\" href=\"#spring简介\">#</a> Spring 简介</h1>\n<p>Spring 是一个轻量级 Java 开发框架，最早有 Rod Johnson 创建，目的是为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题。它是一个分层的 JavaSE/JavaEE full-stack（一站式）轻量级开源框架，为开发 Java 应用程序提供全面的基础架构支持。Spring 负责基础架构，因此 Java 开发者可以专注于应用程序的开发。</p>\n<p>Spring 最根本的使命是解决企业级应用开发的复杂性，即简化 Java 开发。</p>\n<p>Spring 可以做很多事情，它为企业级开发提供了丰富的功能，但是这些功能的底层都依赖于它的两个核心特性，也就是依赖注入（dependency injection，DI）和面向切面编程（aspect-oriented programming，AOP）。</p>\n<p>为了降低 Java 开发的复杂性，Spring 采取了以下 4 种关键策略：</p>\n<ol>\n<li>基于 POJO 的轻量级和最小侵入性编程；</li>\n<li>通过依赖注入和面向接口实现松耦合；</li>\n<li>基于切面和惯例进行声明式编程；</li>\n<li>通过切面和模板减少样板式代码。</li>\n</ol>\n<h1 id=\"spring框架核心\"><a class=\"markdownIt-Anchor\" href=\"#spring框架核心\">#</a> Spring 框架核心</h1>\n<p>Spring 设计目标：Spring 为开发者提供一个一站式轻量级应用开发平台；</p>\n<p>Spring 设计理念：在 JavaEE 开发中，支持 POJO 和 JavaBean 开发方式，使应用面向接口开发，充分支持 OO（面向对象）设计方法；Spring 通过 IoC 容器实现对象耦合关系的管理，并实现依赖反转，将对象之间的依赖关系交给 IoC 容器，实现解耦；</p>\n<p>Spring 框架的核心：IoC 容器和 AOP 模块。通过 IoC 容器管理 POJO 对象以及他们之间的耦合关系；通过 AOP 以动态非侵入的方式增强服务。</p>\n<h1 id=\"spring的优缺点\"><a class=\"markdownIt-Anchor\" href=\"#spring的优缺点\">#</a> Spring 的优缺点</h1>\n<h2 id=\"优点\"><a class=\"markdownIt-Anchor\" href=\"#优点\">#</a> 优点</h2>\n<h3 id=\"方便解耦简化开发\"><a class=\"markdownIt-Anchor\" href=\"#方便解耦简化开发\">#</a> 方便解耦，简化开发</h3>\n<p>Spring 就是一个大工厂，可以将所有对象的创建和依赖关系的维护，交给 Spring 管理。</p>\n<h3 id=\"aop编程的支持\"><a class=\"markdownIt-Anchor\" href=\"#aop编程的支持\">#</a> AOP 编程的支持</h3>\n<p>Spring 提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能。</p>\n<h3 id=\"声明式事务的支持\"><a class=\"markdownIt-Anchor\" href=\"#声明式事务的支持\">#</a> 声明式事务的支持</h3>\n<p>只需要通过配置就可以完成对事务的管理，而无需手动编程。</p>\n<h3 id=\"方便程序的测试\"><a class=\"markdownIt-Anchor\" href=\"#方便程序的测试\">#</a> 方便程序的测试</h3>\n<p>Spring 对 Junit4 支持，可以通过注解方便的测试 Spring 程序。</p>\n<h3 id=\"方便集成各种优秀框架\"><a class=\"markdownIt-Anchor\" href=\"#方便集成各种优秀框架\">#</a> 方便集成各种优秀框架</h3>\n<p>Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架的直接支持（如：Struts、Hibernate、MyBatis 等）。</p>\n<h3 id=\"降低javaee-api的使用难度\"><a class=\"markdownIt-Anchor\" href=\"#降低javaee-api的使用难度\">#</a> 降低 JavaEE API 的使用难度</h3>\n<p>Spring 对 JavaEE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等），都提供了封装，使这些 API 应用难度大大降低。</p>\n<h2 id=\"缺点\"><a class=\"markdownIt-Anchor\" href=\"#缺点\">#</a> 缺点</h2>\n<p>Spring 明明一个很轻量级的框架，却给人感觉大而全<br>\n Spring 依赖反射，反射影响性能<br>\n使用门槛升高，入门 Spring 需要较长时间<br>\n Spring 的应用场景<br>\n应用场景：JavaEE 企业应用开发，包括 SSH、SSM 等</p>\n<h2 id=\"spring价值\"><a class=\"markdownIt-Anchor\" href=\"#spring价值\">#</a> Spring 价值</h2>\n<p>Spring 是非侵入式的框架，目标是使应用程序代码对框架依赖最小化；<br>\nSpring 提供一个一致的编程模型，使应用直接使用 POJO 开发，与运行环境隔离开来；<br>\nSpring 推动应用设计风格向面向对象和面向接口开发转变，提高了代码的重用性和可测试性；</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTMyODM1L2FydGljbGUvZGV0YWlscy8xMDk2OTQxOTY=\">Springboot 介绍</span></p>\n",
            "tags": [
                "java"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/03/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%AC%E4%B8%89%E7%AB%A0/",
            "url": "https://ashgen.gitee.io/2023/03/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%AC%E4%B8%89%E7%AB%A0/",
            "title": "第三章",
            "date_published": "2023-03-17T14:13:25.000Z",
            "content_html": "<h1 id=\"完整性约束的三个子句\"><a class=\"markdownIt-Anchor\" href=\"#完整性约束的三个子句\">#</a> 完整性约束的三个子句</h1>\n<ul>\n<li><strong>主键子句：Primary Key</strong></li>\n</ul>\n<p>体现实体完整性：取值非空、唯一</p>\n<ul>\n<li><strong>外键子句: Foreign Key</strong></li>\n</ul>\n<p>体现参照完整性: References 指出所对应的列名</p>\n<ul>\n<li><strong>检查子句：Check</strong></li>\n</ul>\n<p>用户自定义完整性：指出取值的具体要求</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token keyword\">DISTINCT</span> Sno <span class=\"token keyword\">From</span> SC</pre></td></tr></table></figure><p>DISTINCT 的作用是删除重复值</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">Select</span> sno</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">From</span> SC</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">Group</span> <span class=\"token keyword\">by</span> sno</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">Having</span> <span class=\"token function\">count</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">></span><span class=\"token number\">3</span></pre></td></tr></table></figure><p>where 与 having 的区别在于作用对象不同 where 作用于基本表或视图，选出满足条件的元组；having 作用于组，选择满足条件的组。</p>\n",
            "tags": [
                "XXX"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/03/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/",
            "url": "https://ashgen.gitee.io/2023/03/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E7%90%86%E8%AE%BA/",
            "title": "第六章关系数据理论",
            "date_published": "2023-03-17T08:19:25.000Z",
            "content_html": "<p><strong>关系模式</strong>是对元组集合形式化的描述，R (U，D，Dom，F）</p>\n<p>其中 R 为关系名，U 为属性集，D 为属性来自的域，Dom 为属性向域的映象集合，F 为属性间数据的赖关系集合。简写成: R&lt;U，F&gt;。关系模式是静态的，关系是动态的，不同时刻模式中的关系可能不同，但必须满足模式中 F 所指定的完整性约束条件。</p>\n",
            "tags": [
                "数据库"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/03/17/C/C++%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/",
            "url": "https://ashgen.gitee.io/2023/03/17/C/C++%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/",
            "title": "C++实用函数",
            "date_published": "2023-03-17T08:18:25.000Z",
            "content_html": "<h1 id=\"strtok\"><a class=\"markdownIt-Anchor\" href=\"#strtok\">#</a> strtok()</h1>\n<h2 id=\"描述\"><a class=\"markdownIt-Anchor\" href=\"#描述\">#</a> 描述</h2>\n<p>C 库函数 <strong>char *strtok(char *str, const char *delim)</strong> 分解字符串 <strong>str</strong> 为一组字符串，<strong>delim</strong> 为分隔符。</p>\n<h2 id=\"声明\"><a class=\"markdownIt-Anchor\" href=\"#声明\">#</a> 声明</h2>\n<p>下面是 strtok () 函数的声明。</p>\n<pre><code>char *strtok(char *str, const char *delim)\n</code></pre>\n<h2 id=\"参数\"><a class=\"markdownIt-Anchor\" href=\"#参数\">#</a> 参数</h2>\n<ul>\n<li><strong>str</strong> – 要被分解成一组小字符串的字符串。</li>\n<li><strong>delim</strong> – 包含分隔符的 C 字符串。</li>\n</ul>\n<h2 id=\"返回值\"><a class=\"markdownIt-Anchor\" href=\"#返回值\">#</a> 返回值</h2>\n<p>该函数返回被分解的第一个子字符串，如果没有可检索的字符串，则返回一个空指针。</p>\n<h2 id=\"实例\"><a class=\"markdownIt-Anchor\" href=\"#实例\">#</a> 实例</h2>\n<p>下面的实例演示了 strtok () 函数的用法。</p>\n<h2 id=\"实例-2\"><a class=\"markdownIt-Anchor\" href=\"#实例-2\">#</a> 实例</h2>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h></span> </span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span>  </span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>   </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">char</span> str<span class=\"token punctuation\">[</span><span class=\"token number\">80</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"This is - www.runoob.com - website\"</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> s<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"-\"</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>token<span class=\"token punctuation\">;</span>      <span class=\"token comment\">/* 获取第一个子字符串 */</span>   </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    token <span class=\"token operator\">=</span> <span class=\"token function\">strtok</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">/* 继续获取其他的子字符串 */</span>   </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span> token <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>      </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\"%s\\n\"</span><span class=\"token punctuation\">,</span> token <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>          </pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        token <span class=\"token operator\">=</span> <span class=\"token function\">strtok</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span>      </pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>让我们编译并运行上面的程序，这将产生以下结果：</p>\n<pre><code>This is \n www.runoob.com \n website\n</code></pre>\n<h1 id=\"string中c_str-data-copypn函数的用法\"><a class=\"markdownIt-Anchor\" href=\"#string中c_str-data-copypn函数的用法\">#</a> string 中 c_str ()、data ()、copy (p,n) 函数的用法</h1>\n<p>标准库的 string 类提供了 3 个成员函数来从一个 string 得到 c 类型的字符数组：c_str ()、data ()、copy (p,n)。</p>\n<h2 id=\"c_str生成一个const-char指针指向以空字符终止的数组\"><a class=\"markdownIt-Anchor\" href=\"#c_str生成一个const-char指针指向以空字符终止的数组\">#</a> c_str ()：生成一个 const char * 指针，指向以空字符终止的数组。</h2>\n<p>①这个数组的数据是临时的，当有一个改变这些数据的成员函数被调用后，其中的数据就会失效。因此要么现用先转换，要么把它的数据复制到用户自己可以管理的内存中。注意。看下例：</p>\n<pre><code class=\"language-c++\">const char* c;\nstring s=&quot;1234&quot;;\nc = s.c_str(); \ncout&lt;&lt;c&lt;&lt;endl; //输出：1234\ns=&quot;abcd&quot;;\ncout&lt;&lt;c&lt;&lt;endl; //输出：abcd\n</code></pre>\n<p>上面如果继续用 c 指针的话，导致的错误将是不可想象的。就如：1234 变为 abcd</p>\n<p>其实上面的 c = s.c_str (); 不是一个好习惯。既然 c 指针指向的内容容易失效，我们就应该按照上面的方法，那怎么把数据复制出来呢？这就要用到 strcpy 等函数（推荐）。</p>\n<pre><code class=\"language-c++\">//const char* c; //①\n//char* c;       //②\n//char c[20]; \nchar* c=new char[20];\nstring s=&quot;1234&quot;;\n//c = s.c_str(); \nstrcpy(c,s.c_str());\ncout&lt;&lt;c&lt;&lt;endl; //输出：1234\ns=&quot;abcd&quot;;\ncout&lt;&lt;c&lt;&lt;endl; //输出：1234\n</code></pre>\n<p>注意：不能再像上面一样①所示了，const 还怎么向里面写入值啊；也不能②所示，使用了未初始化的局部变量 “c”，运行会出错的 。</p>\n<p>② c_str () 返回一个客户程序可读不可改的指向字符数组的指针，不需要手动释放或删除这个指针。</p>\n<p><strong>data (): 与 c_str () 类似，但是返回的数组不以空字符终止。</strong></p>\n<h1 id=\"sort\"><a class=\"markdownIt-Anchor\" href=\"#sort\">#</a> sort()</h1>\n<p>对指定范围内元素进行快速排序</p>\n<p>sort 是 STL 自带的系统函数，它的格式是：</p>\n<p>void sort (要排序元素的起始地址，要排序元素的结束地址，比较函数)；</p>\n<p>这里可以省略比较函数，他是默认从小到大排序的（升序排序）</p>\n<pre><code class=\"language-c++\">#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n&#123;\n\tint a[]=&#123;3,5,2,6,9,3,5&#125;;\n\tsort(a,a+7);//7是数组的元素个数，这里a为数组的开头，a+7就等于排序到数组的第七个元素\n\tfor(int i=0;i&lt;6;i++)\n\t\tcout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;\n&#125;\n</code></pre>\n<p>输出:</p>\n<p>2 3 3 5 5 6</p>\n<p>void sort (要排序元素的起始地址，要排序元素的结束地址，比较函数)；</p>\n<p>这个比较函数的作用就是可以自定义排序方式，比如降序排序。</p>\n<p>定义：bool cmp (int x,int y)…，如果返回 True 那么 x 就排在 y 前面。</p>\n<pre><code class=\"language-c++\">#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nbool cmp(int x,int y)\n&#123;\n\tif(x&gt;y)return true;//降序\n\treturn false;\n&#125;\nint main()\n&#123;\n\tint a[]=&#123;3,5,2,6,9,3,5&#125;;\n\tsort(a,a+7,cmp);//7是数组的元素个数\n\tfor(int i=0;i&lt;6;i++)\n\t\tcout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;\n&#125;\n</code></pre>\n<p>输出：</p>\n<p>9 6 5 5 3 3</p>\n<h1 id=\"map\"><a class=\"markdownIt-Anchor\" href=\"#map\">#</a> Map</h1>\n<p>map 是 STL 的一个关联容器，它提供一对一的 hash。</p>\n<p>第一个可以称为关键字 (key)，每个关键字只能在 map 中出现一次；<br>\n第二个可能称为该关键字的值 (value)；<br>\n定义：<br>\nmap &lt;类型，类型&gt; m;<br>\n 举个栗子:<br>\n 记录每个人的名字的对应的爱好，张三喜欢吃汉堡：</p>\n<pre><code class=\"language-c++\">#include&lt;map&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n&#123;\n\tmap&lt;string,string&gt; m;\n\tm[&quot;张三&quot;]=&quot;吃汉堡&quot;;\n\tcout&lt;&lt;&quot;张三: &quot;&lt;&lt;m[&quot;张三&quot;]; \n&#125;\n</code></pre>\n<p>输出：</p>\n<p>张三：吃汉堡</p>\n<h1 id=\"stack栈\"><a class=\"markdownIt-Anchor\" href=\"#stack栈\">#</a> stack (栈)</h1>\n<p>头文件:</p>\n<p>#include<stack><br>\nstack 好像还有个翻译叫 “咸鱼”… 嘿嘿。</stack></p>\n<p>栈的介绍：<br>\n栈就像一个盒子，可以放入或去除元素，但是个人类都知道，要把盒子底下的东西取出来，就必须先取出他上面的东西。</p>\n<p>假如我们把 1、2、3、4、5 按顺序分别入栈：</p>\n<p>栈的定义：<br>\nstack &lt;类型 (可以不写)&gt; st;<br>\n 或者 stack st;<br>\n 很 easy 是不？</p>\n<p>栈的成员函数：<br>\n.empty ()\t判断栈是否为空，空则返回 true<br>\n.pop ()\t移除栈顶元素<br>\n.push (啥啥啥)\t在栈顶增加元素<br>\n.size ()\t返回栈中元素数目<br>\n.top ()\t返回栈顶元素<br>\n.empty ()  判断栈是否为空。</p>\n<pre><code class=\"language-c++\">stack st;\nif(st.empty())//如果是空那么执行下面代码\n    ......\n</code></pre>\n<p>.push (啥啥啥), 在栈顶增加元素。</p>\n<p>.top ()，返回栈顶元素，记住是返回，要单独输出。</p>\n<pre><code class=\"language-c++\">#include&lt;stack&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nstack&lt;int&gt; st;\nint main()&#123;\n    st.push(5418);\n    cout&lt;&lt;st.top();//输出栈顶元素\n    return 0;\n\n&#125;\n</code></pre>\n<p>输出 5418。</p>\n<p>​</p>\n<p>.size (), 返回栈中元素数目。</p>\n<pre><code class=\"language-c++\">#include&lt;stack&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nstack&lt;int&gt; st;\nint main()&#123;\n    st.push(5418);\n    cout&lt;&lt;st.size();\n    return 0;\n&#125;\n</code></pre>\n<p>输出 1</p>\n<p>.pop ()，移除栈顶元素：</p>\n<pre><code class=\"language-c++\">#include&lt;stack&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nstack&lt;int&gt; st;\nint main()&#123;\n    \n\n    st.push(1452);\n    st.push(5418);\n    st.pop();\n    cout&lt;&lt;st.top();\n    \n    return 0;\n\n&#125;\n</code></pre>\n<p>输出 1452。</p>\n<p>简单不？</p>\n<h1 id=\"二分查找\"><a class=\"markdownIt-Anchor\" href=\"#二分查找\">#</a> 二分查找</h1>\n<p>头文件：</p>\n<pre><code class=\"language-c++\">#include &lt;algorithm&gt;\n</code></pre>\n<p>美妙的函数：</p>\n<h2 id=\"1lower_bound函数\"><a class=\"markdownIt-Anchor\" href=\"#1lower_bound函数\">#</a> 1.lower_bound 函数</h2>\n<p>对于有序容器，有序容器，有序容器（重要的事情说三遍）快速二分查找出第一个大于等于</p>\n<p>指定数的位置（下标），如果没有找到，返回最后一个数据后面的位置。</p>\n<p>对于数组，通常的格式为：</p>\n<p>查找的数组下标 = lower_bound (数组要查找的开始位置，数组要查找的结束位置后面，要找的数) – 数组开始位置 (一般写数组名);</p>\n<p>比如：</p>\n<pre><code class=\"language-c++\">#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\n\nusing namespace std;\n\nint main() &#123;\n\n    int a[5] = &#123; 1,2,3,3,8 &#125;;\n     \n    //从 a 数组中找到第一个不小于   3 的元素\n     \n    int   index = lower_bound(a, a + 5, 3)-a;//查找的数组下标 = lower_bound(数组要查找的开始位置，数组要查找的结束位置后面，要找的数) – 数组开始位置;\n     \n    if   (index==5 ) cout &lt;&lt; &quot; not found! &quot;;//index=5，也就是数组末尾的位置。\n    else  cout &lt;&lt; index;\n     \n    return   0;\n\n&#125;\n</code></pre>\n<p>输出 2。</p>\n<h2 id=\"2upper_bound函数\"><a class=\"markdownIt-Anchor\" href=\"#2upper_bound函数\">#</a> 2.upper_bound 函数</h2>\n<p>有一个类似 lower_bound 的函数 upper_bound, 快速二分查找出第一个大于指定数的位置（下</p>\n<p>标），如果没有找到，返回最后一个数据后面的位置。</p>\n<p>举个栗子，啊… 快没栗子了。(っ °Д °;) っ</p>\n<pre><code class=\"language-c++\">#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\n\nusing namespace std;\n\nint main() &#123;\n\n    int a[5] = &#123; 1,2,3,3,8 &#125;;\n    //从 a 数组中找到第一个大于 3 的元素\n     \n    int   index = upper_bound(a, a + 5, 3)-a;\n     \n    if   (index==5 ) cout &lt;&lt; &quot; not found! &quot;;\n    else cout &lt;&lt; index;\n     \n    return   0;\n\n&#125;\n</code></pre>\n<p>输出 4.</p>\n<h2 id=\"3binary_search查找数组内某个元素是否出现\"><a class=\"markdownIt-Anchor\" href=\"#3binary_search查找数组内某个元素是否出现\">#</a> 3.binary_search：查找数组内某个元素是否出现。</h2>\n<p>void binary_search (数组首地址，结束地址，要查找的数)</p>\n<p>返回值为 bool 类型，找到了返回 true。</p>\n",
            "tags": [
                "XXX"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%AC%E5%85%AB%E7%AB%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/",
            "url": "https://ashgen.gitee.io/2023/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%AC%E5%85%AB%E7%AB%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/",
            "title": "第八章：数据库编程",
            "date_published": "2023-03-12T12:23:25.000Z",
            "content_html": "<p><strong>终端交互方式下使用一一交互式 SQL</strong><br>\n<strong> 嵌入在高级语言中使用一一嵌入式 SQL</strong></p>\n<h1 id=\"嵌入式sql\"><a class=\"markdownIt-Anchor\" href=\"#嵌入式sql\">#</a> 嵌入式 SQL</h1>\n<h2 id=\"实现方法\"><a class=\"markdownIt-Anchor\" href=\"#实现方法\">#</a> 实现方法</h2>\n<ol>\n<li>\n<p>扩充宿主语言（C 语言、PASCAL 语言等高级语言）编译程序，使之支持 SQL</p>\n</li>\n<li>\n<p>将嵌入 SQL 的宿主语言转化为预处理程序</p>\n</li>\n</ol>\n<h1 id=\"游标\"><a class=\"markdownIt-Anchor\" href=\"#游标\">#</a> 游标</h1>\n<p>SQL 一次处理一组记录，主语言一次处理一个记录。游标是一个数据缓冲区，存放 SQL 的查询结果，等待主变量取用。</p>\n<h1 id=\"存储过程\"><a class=\"markdownIt-Anchor\" href=\"#存储过程\">#</a> <strong>存储过程</strong></h1>\n<p>类似 C 语言中的函数，包含数据操纵语句、变量、逻辑控制语句等。</p>\n<p><strong>系统存储过程</strong>：以 sp 开头，用来进行系统的各项设定，取得信息，相关管理工作。</p>\n<p>sp_help 就是取得指定对象的相关信息。</p>\n<p><strong>扩展存储过程</strong>：以 xp 开头，用来调用操作系统提供的功能。<br>\nexec master…xp cmdshe11 ‘ping 10.8.16.1’</p>\n<p><strong>用户自定义的存储过程</strong>：由用户在自己的数据库中创建的存储过程，类似 C 语言中的用户自定义函数</p>\n",
            "tags": [
                "数据库"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/",
            "url": "https://ashgen.gitee.io/2023/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/",
            "title": "第十一章：并发控制",
            "date_published": "2023-03-12T12:16:25.000Z",
            "content_html": "<h1 id=\"并发的好处\"><a class=\"markdownIt-Anchor\" href=\"#并发的好处\">#</a> 并发的好处</h1>\n<ol>\n<li>改善系统资源利用率</li>\n<li>改善短事务的响应时间</li>\n</ol>\n<h1 id=\"并发的坏处\"><a class=\"markdownIt-Anchor\" href=\"#并发的坏处\">#</a> 并发的坏处</h1>\n<ol>\n<li>\n<p>丢失修改</p>\n<p>事务 A 和 B 读入同一数据并修改，B 提交的结果破坏了 A 提交的</p>\n</li>\n<li>\n<p>不可重复读</p>\n<p>A 读取后，B 修改，A 再读就不一样了</p>\n</li>\n<li>\n<p>读脏数据</p>\n<p>A 修改后，B 读，A 被撤销，B 读到的数据就是脏数据</p>\n</li>\n</ol>\n<h1 id=\"加锁\"><a class=\"markdownIt-Anchor\" href=\"#加锁\">#</a> 加锁</h1>\n<p>几个事务的并行执行是正确的，当且仅当其结果与按某一个次序串行执行事务的结果相同</p>\n<p>排他锁（写锁，X 锁），加上后不能再加其他任何锁</p>\n<p>共享锁（读锁，S 锁），加上后可以再加 S 锁</p>\n<p><strong>一级封锁协议</strong>：事务在修改数据之前必须加 X 锁，事务结束时释放，可防止丢失修改</p>\n<p><strong>二级封锁协议</strong>：一级协议的基础上加上事务在读取数据之前必须加 S 锁，<strong>读完释放</strong>，可防止读脏数据</p>\n<p><strong>三级封锁协议</strong>：一级协议的基础上加上事务在读取数据之前必须加 S 锁，<strong>事务结束时释放</strong>，保证可重复读</p>\n<p><strong>活锁</strong>：某个事务永远处于等待状态，解决方法：先来先服务</p>\n<p><strong>死锁</strong>：多个事务都在等待另一个解除封锁，解决方法：死锁预防、死锁检测</p>\n<p>若一个并行调度的结果等价于某个串行调度的结果，则该并行调度称为<strong>可串行化的调度</strong></p>\n<h1 id=\"两段锁协议\"><a class=\"markdownIt-Anchor\" href=\"#两段锁协议\">#</a> 两段锁协议</h1>\n<p>在对任何数据进行读、写之前，事务必须首先获得该数据的封锁。在释放一个封锁后，事务不得再获得任何其他封锁。即将事务分为两个阶段，第一为获得封锁，第二为释放封锁。</p>\n<p>遵循两段锁协议仍可能死锁。</p>\n<p>对任何一个事务而言，在调度中获得其最后一个锁的时刻，称为该事务的<strong>封锁点</strong>。</p>\n",
            "tags": [
                "数据库"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%AC%E5%8D%81%E7%AB%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/",
            "url": "https://ashgen.gitee.io/2023/03/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%AC%E5%8D%81%E7%AB%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF/",
            "title": "第十章：数据库系统概述",
            "date_published": "2023-03-12T12:15:25.000Z",
            "content_html": "<p><strong>事务</strong>即数据库操作序列，是一个不可分割的工作单位。是恢复和并发控制的基本单位</p>\n<p><strong>事物的 ACID 特性</strong>：<br>\n（1）原子性 (Atomicity)：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成<br>\n功，要么全部失败回滚。回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，<br>\n在回滚时反向执行这些修改操作即可。<br>\n（2）一致性 (Consistency)：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有<br>\n事务对一个数据的读取结果都是相同的。<br>\n（3）隔离性 (Isolation)：一个事务所做的修改在最终提交以前，对其它事务是不可见的。<br>\n（4）持久性 (Durability)：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统<br>\n发生崩溃，事务执行的结果也不能丢失。</p>\n<h1 id=\"故障分类\"><a class=\"markdownIt-Anchor\" href=\"#故障分类\">#</a> 故障分类</h1>\n<ol>\n<li>\n<p>事务内部故障</p>\n<p>恢复操作是<strong>事务撤销</strong></p>\n</li>\n<li>\n<p>系统故障（软故障）</p>\n</li>\n<li>\n<p>介质故障（硬故障）</p>\n</li>\n<li>\n<p>计算机病毒</p>\n</li>\n</ol>\n<h1 id=\"数据转储分类\"><a class=\"markdownIt-Anchor\" href=\"#数据转储分类\">#</a> 数据转储分类</h1>\n<table>\n<thead>\n<tr>\n<th></th>\n<th><strong>动态转储</strong></th>\n<th><strong>静态转储</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>海量转储</strong></td>\n<td>动态海量转储</td>\n<td>静态海量转储</td>\n</tr>\n<tr>\n<td><strong>增量转储</strong></td>\n<td>动态增量转储</td>\n<td>静态增量转储</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"日志文件\"><a class=\"markdownIt-Anchor\" href=\"#日志文件\">#</a> 日志文件</h1>\n<p>记录事务对数据库的更新操作</p>\n",
            "tags": [
                "数据库"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%AC%E4%B8%83%E7%AB%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/",
            "url": "https://ashgen.gitee.io/2023/03/11/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%AC%E4%B8%83%E7%AB%A0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/",
            "title": "",
            "date_published": "2023-03-11T12:19:10.984Z",
            "content_html": "<p>数据库设计是<strong>结构设计</strong>与<strong>行为设计</strong>的结合</p>\n<p><strong>结构设计</strong>一一系统的静态描述，括模式、子模式的描述，即设计数据库框架或数据库结构</p>\n<p><strong>行为设计</strong>一一系统的动态描述，即设计应用程序、事务处理等<br>\n<strong>将数据库与对数据库的操作分离设计</strong></p>\n<p><img data-src=\"image-20230311164839977-16785372180531.png\" alt=\"image-20230311164839977\"></p>\n<h1 id=\"数据库设计基本步骤\"><a class=\"markdownIt-Anchor\" href=\"#数据库设计基本步骤\">#</a> 数据库设计基本步骤</h1>\n<ol>\n<li>\n<p>需求分析</p>\n<p>分析用户基本要求，确定系统边界，分析数据和处理过程，编写系统分析报告</p>\n</li>\n<li>\n<p>概念结构设计</p>\n<p>将求分析抽象为概念模型的过程 (E-R 图）</p>\n</li>\n<li>\n<p>逻辑结构设计</p>\n<p>将概念模型转换为计算机支持的数据模型的过程</p>\n</li>\n<li>\n<p>物理结构设计</p>\n<p>为逻辑数据模型选取适当的物理结构的过程</p>\n</li>\n<li>\n<p>数据库实施</p>\n<p>数据的载入，应用程序的编制与调试</p>\n</li>\n<li>\n<p>数据库运行维护</p>\n<p>系统运行过程中的评价、维护与调整</p>\n<h1 id=\"数据库各级模式的形成\"><a class=\"markdownIt-Anchor\" href=\"#数据库各级模式的形成\">#</a> 数据库各级模式的形成</h1>\n<p>数据库的各级模式是在设计过程中逐步形成的</p>\n<p>需求分析阶段</p>\n<p>综合各个用户的应用需求 (现实世界的需求)<br>\n 概念设计阶段形成独立于机器特点、独立于各个 DBMS 产品的<strong>概念模式</strong> (信息世界模型)，用 E-R 图来描述。<br>\n在逻辑设计阶段将 E-R 图转换成具体的数据库产品支持的逻辑模型如关系模型，形成数据库<strong>逻辑模式</strong>。然后根据用户处理的要求，安全性的考虑，在基本表的基础上再建立必要的视图 (VIEW) 形成数据的<strong>外模式</strong>。<br>\n在物理设计阶段根据 DBMS 特点和处理的要进行物理存储安排，设计索引，形成数据库<strong>内模式</strong>。</p>\n</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "https://ashgen.gitee.io/2023/03/08/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/%E4%B8%93%E4%B8%9A%E9%97%AE%E9%A2%98/",
            "url": "https://ashgen.gitee.io/2023/03/08/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/%E4%B8%93%E4%B8%9A%E9%97%AE%E9%A2%98/",
            "title": "专业问题",
            "date_published": "2023-03-08T13:46:25.000Z",
            "content_html": "<h1 id=\"数据结构类\"><a class=\"markdownIt-Anchor\" href=\"#数据结构类\">#</a> 数据结构类</h1>\n<h2 id=\"b树和b树的区别\"><a class=\"markdownIt-Anchor\" href=\"#b树和b树的区别\">#</a> B 树和 B + 树的区别？</h2>\n<ul>\n<li>B 树在所有结点都存数据，B + 树只在叶子结点存数据</li>\n<li>B + 树支持遍历叶子结点，B 树不支持</li>\n</ul>\n<h2 id=\"说几种排序的算法\"><a class=\"markdownIt-Anchor\" href=\"#说几种排序的算法\">#</a> 说几种排序的算法</h2>\n<p>选择、冒泡、插入、快速、堆、归并排序</p>\n<h2 id=\"快速排序的思想\"><a class=\"markdownIt-Anchor\" href=\"#快速排序的思想\">#</a> 快速排序的思想？</h2>\n<h2 id=\"快速排序在数据基本有序的情况下时间复杂度会达到onn如何改进\"><a class=\"markdownIt-Anchor\" href=\"#快速排序在数据基本有序的情况下时间复杂度会达到onn如何改进\">#</a> 快速排序在数据基本有序的情况下时间复杂度会达到 O (n*n)，如何改进？</h2>\n<ul>\n<li>头、尾、中间三个元素取中间值作为基准元素</li>\n<li>在一次分割结束后，可以把与 Key 相等的元素聚在一起，继续下次分割时，不用再对与 key 相等元素分割</li>\n</ul>\n<h2 id=\"c中有拷贝构造函数什么时候需要重写拷贝构造函数\"><a class=\"markdownIt-Anchor\" href=\"#c中有拷贝构造函数什么时候需要重写拷贝构造函数\">#</a> C++ 中有拷贝构造函数，什么时候需要重写拷贝构造函数？</h2>\n<p>拷贝构造函数是使用类对象的引用作为参数的构造函数，它能够将参数的属性值拷贝给新的对象，完成新对象的初始化。一般三种情况我们可能需要重写拷贝构造函数</p>\n<ol>\n<li>使用一个对象初始化另一个对象</li>\n<li>对象作为实参传递给参数</li>\n<li>函数返回值为类对象，创建临时对象作为返回值</li>\n</ol>\n<h2 id=\"什么是抽象类\"><a class=\"markdownIt-Anchor\" href=\"#什么是抽象类\">#</a> 什么是抽象类</h2>\n<p>如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类不能实例化对象，所以抽象类必须被继承，才能被使用</p>\n<h2 id=\"头指针和头结点的区别\"><a class=\"markdownIt-Anchor\" href=\"#头指针和头结点的区别\">#</a> 头指针和头结点的区别</h2>\n<p>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针</p>\n<p>头结点是为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义</p>\n<h2 id=\"bfs和dfs的区别\"><a class=\"markdownIt-Anchor\" href=\"#bfs和dfs的区别\">#</a> BFS 和 DFS 的区别</h2>\n<p>DFS 使用栈，相当于二叉树的先序遍历</p>\n<p>BFS 使用队列，相当于二叉树的层序遍历</p>\n<h2 id=\"什么是稳定的排序算法\"><a class=\"markdownIt-Anchor\" href=\"#什么是稳定的排序算法\">#</a> 什么是稳定的排序算法</h2>\n<p>序列中，存在多个具有相同的关键字的记录，经过排序，这些记录的相对次序保持不变</p>\n<h2 id=\"堆排序的排序过程\"><a class=\"markdownIt-Anchor\" href=\"#堆排序的排序过程\">#</a> 堆排序的排序过程</h2>\n<h1 id=\"操作系统类\"><a class=\"markdownIt-Anchor\" href=\"#操作系统类\">#</a> 操作系统类</h1>\n<h2 id=\"进程的7个状态\"><a class=\"markdownIt-Anchor\" href=\"#进程的7个状态\">#</a> 进程的 7 个状态</h2>\n<p>创建、就绪、运行、阻塞、终止、就绪挂起、阻塞挂起</p>\n<h2 id=\"操作系统如何实现内存保护\"><a class=\"markdownIt-Anchor\" href=\"#操作系统如何实现内存保护\">#</a> 操作系统如何实现内存保护</h2>\n<ul>\n<li><strong>上、下限寄存器</strong></li>\n<li><strong>重定位寄存器</strong>和<strong>界地址寄存器</strong></li>\n</ul>\n<h2 id=\"进程控制块包含哪些信息\"><a class=\"markdownIt-Anchor\" href=\"#进程控制块包含哪些信息\">#</a> 进程控制块包含哪些信息</h2>\n<p><strong>进程标识、进程状态、优先级、中断现场、所占资源</strong></p>\n<h2 id=\"用户态和内核态之间的转换\"><a class=\"markdownIt-Anchor\" href=\"#用户态和内核态之间的转换\">#</a> 用户态和内核态之间的转换</h2>\n<p>用户态 ——&gt; 内核态：系统调用、中断、异常、主程序出错</p>\n<p>内核态 ——&gt; 用户态：使用修改 CPU 状态寄存器这一特权指令</p>\n<h2 id=\"中断和异常几种情况看一下\"><a class=\"markdownIt-Anchor\" href=\"#中断和异常几种情况看一下\">#</a> 中断和异常几种情况看一下</h2>\n<h1 id=\"数据库类\"><a class=\"markdownIt-Anchor\" href=\"#数据库类\">#</a> 数据库类</h1>\n<h2 id=\"mysql中的索引是用什么实现的\"><a class=\"markdownIt-Anchor\" href=\"#mysql中的索引是用什么实现的\">#</a> Mysql 中的索引是用什么实现的？</h2>\n<p>B 树和 B + 树</p>\n<h2 id=\"什么是数据库\"><a class=\"markdownIt-Anchor\" href=\"#什么是数据库\">#</a> 什么是数据库</h2>\n<p>按照数据结构来组织、存储和管理数据的仓库</p>\n<h2 id=\"数据库中索引的作用和优缺点\"><a class=\"markdownIt-Anchor\" href=\"#数据库中索引的作用和优缺点\">#</a> 数据库中索引的作用和优缺点</h2>\n<p>为了提高查询速度而对表字段附加的一种标识</p>\n<p>优点是能提高查询的速度</p>\n<p>缺点是会增大数据库的数据量</p>\n<h1 id=\"计算机网络类\"><a class=\"markdownIt-Anchor\" href=\"#计算机网络类\">#</a> 计算机网络类</h1>\n<h2 id=\"udp的主要特点\"><a class=\"markdownIt-Anchor\" href=\"#udp的主要特点\">#</a> UDP 的主要特点</h2>\n<p>无连接、尽最大努力交付、没有拥塞控制、首部开销小、支持一对多通信</p>\n<h1 id=\"神经网络类\"><a class=\"markdownIt-Anchor\" href=\"#神经网络类\">#</a> 神经网络类</h1>\n<h2 id=\"深度神经网络为什么要用非线性激活函数\"><a class=\"markdownIt-Anchor\" href=\"#深度神经网络为什么要用非线性激活函数\">#</a> 深度神经网络为什么要用非线性激活函数</h2>\n<p>如果不用激活函数，每一层输出都是上层输入的线性函数，很容易验证，无论你神经网络有多少层，输出都是输入的线性组合，与没有隐藏层效果相当</p>\n<h2 id=\"sigmoid激活函数和softmax激活函数的主要区别\"><a class=\"markdownIt-Anchor\" href=\"#sigmoid激活函数和softmax激活函数的主要区别\">#</a> sigmoid 激活函数和 softmax 激活函数的主要区别</h2>\n<p>softmax 的计算的是一个比重，而 sigmoid 只是对每一个输出值进行非线性化。</p>\n",
            "tags": [
                "XXX"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/03/08/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/%E8%8B%B1%E8%AF%AD%E9%97%AE%E9%A2%98/",
            "url": "https://ashgen.gitee.io/2023/03/08/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/%E8%8B%B1%E8%AF%AD%E9%97%AE%E9%A2%98/",
            "title": "英语问题",
            "date_published": "2023-03-08T13:46:25.000Z",
            "content_html": "<h1 id=\"自我介绍\"><a class=\"markdownIt-Anchor\" href=\"#自我介绍\">#</a> 自我介绍</h1>\n<p>Good morning. I am glad to be here for this interview. My name is Zhang YunFeng, 22. I come from Xuancheng City, the southeast of Anhui Province. I major in Computer Science and Technology at BeiJing Wuzi University and will graduate here in this coming June. （介绍自己）</p>\n<p>I am open-minded, quick in thought and very fond of new technology. Frequently I exchange with other people by making comments in the forum on line. I’m also with great perseverance. During the days preparing for the first postgraduate examination, I insist on playing badminton once a week. And just owning to this, I can be active and get along well with others. （基本优点 + 大学生活）</p>\n<p>After four year’s learning, I am deeply attracted by the dynamic and positive atmosphere of our major. So I hope to pursue advanced study to broaden my horizon. And I truly believe, I can be a better person after three year’s learning, of course, if I’m lucky enough to be admitted to the <strong>Beijing Institute of Technology</strong>**.** （报考学校的理由）</p>\n<p>I always believe that one will easily lag behind unless he keeps on learning. Therefore, During my postgraduate study, study and scientific research will be my first priority. I hope I can form a systematic view of computer science and technology and make a solid foundation for future study. I would be very honored if I can do any little contribution in this field. （生涯规划）</p>\n<p>That’s all about my self introduction, thank you!</p>\n<h1 id=\"introduce-my-hometown介绍家乡\"><a class=\"markdownIt-Anchor\" href=\"#introduce-my-hometown介绍家乡\">#</a> Introduce my hometown 介绍家乡</h1>\n<p>I am from a famous city with a long history over 2,000 years. It is called “Xuancheng ”. Xuancheng City is located in the southeast of Anhui Province. It is a thousand year county prefecture with a long history. It has been called Xuancheng County, Xuanzhou and Ningguo Prefecture successively. Known as “Xuancheng ancient poet land”, “Shangjiang humanities flourishing capital Xuancheng” said; Jingting Mountain is known as the “No.1 Poetry Mountain in the South of the Yangtze River”. I think the city really deserves it. Li Bai visited Xuancheng seven times and left more than 80 poems. Visitors at home and abroad feel it comfortable visiting here. There is my beloved hometown.</p>\n<h1 id=\"why-do-you-choose-to-further-study-instead-of-going-to-work-after-graduation为什么考研\"><a class=\"markdownIt-Anchor\" href=\"#why-do-you-choose-to-further-study-instead-of-going-to-work-after-graduation为什么考研\">#</a> Why do you choose to further study instead of going to work after graduation? 为什么考研？</h1>\n<p>Firstly, I am very interested in my major, and I think what I have learned during the undergraduate period is not deep enough. I want to learn more professional knowledge and further improve myself through the three-year postgraduate study.</p>\n<p>Then, my performance in the college entrance examination is not very ideal, and I want to be admitted to a better school to prove my ability</p>\n<p>In a word, I look forward to laying a solid foundation for my future career after completing my studies here.</p>\n<h1 id=\"introduce-your-favorite-sportintroduce-your-hobby\"><a class=\"markdownIt-Anchor\" href=\"#introduce-your-favorite-sportintroduce-your-hobby\">#</a> Introduce your favorite sport/Introduce your hobby</h1>\n<p>My favorite sport is playing badminton. Playing badminton needs the cooperation of eyes, hands and feet.During the days preparing for the first postgraduate examination, I insist on playing badminton once a week. Through playing badminton, I developed my team spirit and learned how to cooperate with others to win games. It also improves my communication skills, enables me to get a good interpersonal relationship, and can prevent myopia, which is also good for cervical spine.</p>\n<h1 id=\"introduce-my-family介绍家庭\"><a class=\"markdownIt-Anchor\" href=\"#introduce-my-family介绍家庭\">#</a> Introduce my family 介绍家庭</h1>\n<p>​    In my family, there are three members, my father, my mother and me. My parents are workers, my father works very hard, he is always busy, so most of the housework is done by my mother, of course, when I am at home, I will help her. When I make a success, they are more excited than me, and support me to do better. Even though I failed, instead of blaming, they always share sorrow with me, and encourage me not to give up. So I will do all what I can to repay them.</p>\n<h1 id=\"introduce-my-school介绍学校\"><a class=\"markdownIt-Anchor\" href=\"#introduce-my-school介绍学校\">#</a> Introduce my school 介绍学校</h1>\n<p>My university, Beijing Wuzi University, is located in Beijing, the capital of China. It is a university characterized by logistics and circulation, based on economics and centered on management. Founded in 1980, it has been subordinate to the State General Administration of Materials, the Ministry of Materials and the Ministry of Domestic Trade. The university offers 28 undergraduate programs and 17 authorized disciplines for master’s degrees. In April 2022, the Youth League Committee of Beijing Materials University was honored as the “Beijing May 4th Red Flag Youth League Committee”.</p>\n<p>我的学校是北京物资学院，坐落于中国首都北京市，是一所以物流和流通为特色，以经济学科为基础，以管理学科为主干的大学。它于 1980 年建校，先后隶属于国家物资总局、物资部、国内贸易部。学校开设 28 个本科专业，拥有 17 个硕士授权学科。2022 年 4 月，北京物资学院团委被表彰为 “北京市五四红旗团委”。</p>\n<h1 id=\"talk-about-your-favorite-courses谈谈你最喜欢的课程\"><a class=\"markdownIt-Anchor\" href=\"#talk-about-your-favorite-courses谈谈你最喜欢的课程\">#</a> Talk about your favorite courses 谈谈你最喜欢的课程</h1>\n<p>My favorite course is data structures. Data structure can let us understand the characteristics of computer processing objects, the actual problem involved in the processing objects expressed in the computer and to deal with them. At the same time, I also learned many commonly used algorithms, from which I improved my comprehensive application ability and professional quality.</p>\n<p>我最喜欢的课程是数据结构。数据结构能够让我们了解计算机处理对象的特性，将实际问题中所涉及的处理对象在计算机中表示出来并对它们进行处理。与此同时，我还学习了很多常用的算法，从中提高了综合应用能力和专业素质。</p>\n<h1 id=\"what-is-artificial-intelligence什么是人工智能\"><a class=\"markdownIt-Anchor\" href=\"#what-is-artificial-intelligence什么是人工智能\">#</a> What is Artificial Intelligence 什么是人工智能</h1>\n<p>Artificial intelligence is a branch of computer science that attempts to understand the nature of intelligence and produce new kinds of intelligent machines that can react in a similar way to human intelligence. The main goal is to make machines capable of complex tasks that would normally require human intelligence.</p>\n<p>人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器。其主要目标是使机器能够胜任一些通常需要人类智能才能完成的复杂工作</p>\n<h1 id=\"difference-between-recursion-and-iteration\"><a class=\"markdownIt-Anchor\" href=\"#difference-between-recursion-and-iteration\">#</a> Difference between recursion and iteration</h1>\n<p>Recursion is the program calling itself</p>\n<p>Iteration is to make use of the known variable value and get the new variable value according to the recursion formula</p>\n<p>递归就是指程序调用自身</p>\n<p>迭代是利用已知的变量值，根据递推公式不断演进得到变量新值</p>\n<h1 id=\"也会找英语小短文看过之后翻译\"><a class=\"markdownIt-Anchor\" href=\"#也会找英语小短文看过之后翻译\">#</a> 也会找英语小短文，看过之后翻译</h1>\n",
            "tags": [
                "XXX"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/03/08/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/",
            "url": "https://ashgen.gitee.io/2023/03/08/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/",
            "title": "项目问题",
            "date_published": "2023-03-08T13:46:25.000Z",
            "content_html": "<h1 id=\"springboot的优势\"><a class=\"markdownIt-Anchor\" href=\"#springboot的优势\">#</a> Springboot 的优势</h1>\n<ul>\n<li>通过简化配置可以快速搭建 Spring 应用程序。</li>\n<li>内嵌 servlet 容器，能够直接使用 java 的 main 方法启动，因此也不需要部署 war 包文件。</li>\n<li>提供 starter 简化 Maven 配置。</li>\n</ul>\n<h1 id=\"有监督学习和无监督学习的区别\"><a class=\"markdownIt-Anchor\" href=\"#有监督学习和无监督学习的区别\">#</a> 有监督学习和无监督学习的区别</h1>\n<p>有监督：通过已有的训练样本（即已知数据及其对应的输出）去训练得到一个最优模型</p>\n<p>无监督：由输入数据中学到或建立一个模型，并依此模式推测新的结果。输入数据没有被标记，也没有确定的结果。</p>\n",
            "tags": [
                "XXX"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/03/06/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BB%AA%E8%AE%BA/",
            "url": "https://ashgen.gitee.io/2023/03/06/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%AC%E4%B8%80%E7%AB%A0%E7%BB%AA%E8%AE%BA/",
            "title": "第一章：数据库系统概述",
            "date_published": "2023-03-06T10:46:25.000Z",
            "content_html": "<h1 id=\"基本概念\"><a class=\"markdownIt-Anchor\" href=\"#基本概念\">#</a> <strong>基本概念</strong></h1>\n<p>** 数据：** 数据是描述事物的符号记录，数据的含义称为数据的语义</p>\n<p>** 数据库：** 长期存储、有组织、可共享的大量数据集合</p>\n<p>** 数据库管理系统：** 和操作系统一样是计算机的基础软件</p>\n<p>** 数据库系统：** 由数据库、数据库管理系统、数据库管理员组成</p>\n<h1 id=\"技术的发展阶段\"><a class=\"markdownIt-Anchor\" href=\"#技术的发展阶段\">#</a> <strong>技术的发展阶段</strong></h1>\n<p>人工管理 —— 文件系统 —— 数据库系统</p>\n<h1 id=\"数据模型\"><a class=\"markdownIt-Anchor\" href=\"#数据模型\">#</a> <strong>数据模型</strong></h1>\n<p>是对现实世界数据特征的抽象</p>\n<p>![img](file:///C:/Users/admin/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)</p>\n<p>最常用<strong>实体 - 联系</strong>方法，即<strong> E-R 图</strong>来表示概念模型</p>\n<p>其中逻辑模型中的<strong>关系模型</strong>是重点</p>\n<h1 id=\"数据库系统的三级模式\"><a class=\"markdownIt-Anchor\" href=\"#数据库系统的三级模式\">#</a> 数据库系统的三级模式</h1>\n<p>数据按外模式的描述提供给用户。</p>\n<p>按内模式的描述存储在磁盘中。</p>\n<p>模式提供了连接这两级的相对稳定的中间观点，并使得两级中任何一级的改变不受另一级的牵制。</p>\n<p>** 外模式 / 模式映象：** 保证数据的逻辑独立性</p>\n<p>** 模式 / 内模式映象：** 保证数据的物理独立性</p>\n<p>![img](file:///C:/Users/admin/AppData/Local/Temp/msohtmlclip1/01/clip_image003.png)</p>\n<h1 id=\"数据库系统组成部分\"><a class=\"markdownIt-Anchor\" href=\"#数据库系统组成部分\">#</a> 数据库系统组成部分</h1>\n<p>硬件平台及数据库</p>\n<p>软件支持系统</p>\n<p>各类人员</p>\n",
            "tags": [
                "数据库"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/03/04/C/C++%E9%97%AE%E9%A2%98/",
            "url": "https://ashgen.gitee.io/2023/03/04/C/C++%E9%97%AE%E9%A2%98/",
            "title": "C++问题",
            "date_published": "2023-03-04T03:24:00.000Z",
            "content_html": "<p>使用范围 for 语句时，变量需定义在内部</p>\n<pre><code class=\"language-c++\">for(auto c : line)\n\t\tc=toupper(c);\n</code></pre>\n<h1 id=\"字符串转整数\"><a class=\"markdownIt-Anchor\" href=\"#字符串转整数\">#</a> 字符串转整数</h1>\n<pre><code class=\"language-C++\">string s=&quot;123&quot;;\nstringstream ss;\nint x=0;\nss&lt;&lt;s;\nss&gt;&gt;x;\ncout&lt;&lt;x+1&lt;&lt;endl;\n</code></pre>\n<h1 id=\"整数转字符串\"><a class=\"markdownIt-Anchor\" href=\"#整数转字符串\">#</a> 整数转字符串</h1>\n<pre><code class=\"language-c++\">int s=123;\nstringstream ss;\nstring x;\nss&lt;&lt;s;\nss&gt;&gt;x;\ncout&lt;&lt;x&lt;&lt;endl;\nreturn 0;\n</code></pre>\n",
            "tags": [
                "细节问题"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/03/01/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger%20Fabric%E8%81%94%E7%9B%9F%E9%93%BE%E7%AE%80%E4%BB%8B/",
            "url": "https://ashgen.gitee.io/2023/03/01/%E5%8C%BA%E5%9D%97%E9%93%BE/Hyperledger%20Fabric%E8%81%94%E7%9B%9F%E9%93%BE%E7%AE%80%E4%BB%8B/",
            "title": "联盟链简介",
            "date_published": "2023-03-01T02:31:25.000Z",
            "content_html": "<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85MTQzMTg4NQ==\">区块链交易原理</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC84OTMzMzQwMg==\">公有链、私有链、联盟链的区别</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hb3FpdWtlamkvYXJ0aWNsZS9kZXRhaWxzLzExOTcyOTM3NQ==\">许可区块链与无许可区块链</span></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9oeXBlcmxlZGdlci1mYWJyaWMucmVhZHRoZWRvY3MuaW8vemhfQ04vbGF0ZXN0L2luZGV4Lmh0bWw=\">Hyperledger Fabric 文档</span></p>\n<h1 id=\"什么是挖矿\"><a class=\"markdownIt-Anchor\" href=\"#什么是挖矿\">#</a> 什么是挖矿</h1>\n<p>传统商品的供应链，大家都比较熟悉，简单划分就是：生产 —— 交易 —— 使用。作为一般等价物的比特币，也存在着这 3 个环节：生产 —— 交易 —— 应用。了解了比特币的生产环节，也明白了什么叫做 “挖矿”。</p>\n<p>区块链的本质，是一个分布式的公共账本，是一个记账系统，每一个参与的点，都可以在上边记账。虽然每一个参与的点都有记账的权利，但是这个账到底怎么一个计法？谁来记？怎么记？</p>\n<p>比特币采用了一种叫做 PoW 工作量证明的机制。大概意思是说，每个节点都想记账，那么到底由哪个节点来记呢？计算能力最强大的那一个记喽。</p>\n<p>谁的计算能力最强大呢？那就得比一比了，怎么比？数学竞赛！系统每次会出一道数学题，只有最快解出这道题目的计算机才能进行记账。获得了这个记账权的计算机，同时获得一个单位的比特币奖励。</p>\n<p>“一个单位” 到底是多少？这得从比特币的分配机制说起。比特币是模拟黄金的储量和发行速度的。在储量上，比特别是限量发行的，总量有且只有 2100 万枚。在发行速度上，比特币有个 “减半机制”，每产生 21 万个区块（几乎是每 4 年），就进行一次减半：最开始获得一次记账权，奖励 50 个比特币；2012 年 12 月 28 日，比特币迎来第一次减半，获得一次记账权，奖励只有 25 个比特币；2016 年 7 月 9 日，比特别迎来第二次减半，获得一次记账权，奖励只有 12.5 个比特币了。</p>\n<p>比特币既然模拟黄金，那获得比特币也就被叫做 “挖矿” 了。挖矿，就是计算机们参与到数据竞赛中，并获得比特币奖励的过程。挖矿的人，就叫做矿工。</p>\n<p>最开始算力竞争不激烈的时候，大家在家里或者办公室里，用 CPU 挖矿，然后用 1 万枚比特币买了俩披萨那个哥们儿，开创了用 GPU 挖矿，这股风潮一度带动了 GPU 断货。</p>\n<p>但是挖着挖着，竞争越来越激烈，大家发现 GPU 算力也跟不上了。于是就有了专门的矿机。矿机就是专门用来挖币的电脑，搭载有专业的挖矿晶元，多采用烧显卡的方式工作。矿机有两个缺点：一是产生较大噪音 —— 这也是为什么家庭挖矿不太可行；二是耗电量较大，有网友一台挖矿机 3 个月就用 1000 多度电，这么高的电费，很有可能把挖矿赚的钱抵消，或倒贴赔钱。</p>\n<p>单个矿机作战力还是跟不上，然后就有了矿场和矿池。</p>\n<p>“矿场” 就是把矿机放到一起，集中管理。早期特别粗放，就是弄个架子，把矿机挨个摞到架子上就可以了，后来发现这样会导致矿机损耗，就开始有了通风、隔尘、室内温度湿度等要求。矿场一般建立在电费比较便宜，比较稳定的地方，比如内蒙、四川。得益于中国完善的电力基础设施建设、廉价的火电水电或风电资源，中国力量也一直垄断着比特币矿场。</p>\n<p>“矿池” 则是突破了地理位置的限制 —— 多人合作挖矿，将少量算力合并、联合运作，使用这种方式建立的网站便被称作矿池。</p>\n<h1 id=\"联盟链\"><a class=\"markdownIt-Anchor\" href=\"#联盟链\">#</a> 联盟链</h1>\n<h2 id=\"1-简介\"><a class=\"markdownIt-Anchor\" href=\"#1-简介\">#</a> 1. 简介</h2>\n<p>区块链作为一种分布式账本技术，主要分为许可链和非许可链。其中许可链又分为私有链和联盟链。和 BTC 或 ETH 不同，联盟链是一种需要身份认证的区块链。只有通过认证的节点或组织才能参与联盟链网络中的交易。</p>\n<h2 id=\"2-hyperledger-fabric\"><a class=\"markdownIt-Anchor\" href=\"#2-hyperledger-fabric\">#</a> 2. Hyperledger fabric</h2>\n<p>Hyperledger fabric 是一种联盟链。fabric 网络中的成员都需要在可信赖的成员服务提供者处注册，否则不能参与交易。/<em> 因此围绕联盟链产生了一些争议，一些人认为以 fabric 为代表的联盟链并不是真正的区块链，而另一些人则持反对意见。</em>/</p>\n<p>fabric 有一个特有的功能，通道（channel）。通道中的成员与通道外的成员的相互隔绝的，只有同一个通道的成员能够共享账本，不同通道的成员之间的交易记录是不可互相查询的。值得一提的是，同一个节点可以加入不同的通道。</p>\n<p>fabric 的共识机制是可以拔插的。共识机制是一个分布式系统里的名词，就是在不同的系统中并保持副本的一致性。fabric 允许网络中的节点自行选择最能代表参与者需求的共识机制。</p>\n<p>fabric 中的账本系统包括两个组件：世界状态（数据库）和交易日志（历史记录）。每个参与者都拥有他们所属的 fabric 网络的账本副本。世界状态描述了账本在给定时间点的状态。它是账本的数据库，记录了当前状态的所有交易，是世界状态的更新历史。交易日志是不可插拔的，它只记录区块链网络中使用账本数据库前后的值。</p>\n<h2 id=\"3-fabric的身份\"><a class=\"markdownIt-Anchor\" href=\"#3-fabric的身份\">#</a> 3. Fabric 的身份</h2>\n<p>身份是联盟链区别与公链的一个最重要特征。在公链中是没有身份这个概念的，每个节点都是相同的角色。而<em> fabric 身份是联盟链中最重要的概念，甚至可以没有之一</em>。联盟链中的身份确定了对资源的确切权限以及对参与者在区块链网络中拥有的信息的访问权限。</p>\n<p>整个网络中分为几种角色：peer 节点（提交节点和背书节点），证书颁发机构 CA，其中成员服务提供者（Membership Service Provider, MSP）是一个可信任的权威机构，它不是 fabric 中的角色，但是为 fabric 中的节点提供可信的身份认证。fabric 中，默认的 MSP 实现使用 X.509 证书（使用最广泛的证书结构标准，包括证书信息 / 签名算法 / 数字签名等内容）作为身份，采用公钥基础结构（Pubic Key Infrastructure, PKI）作为分层模型。PKI 是身份供应商，为接入区块链网络的用户提供一个身份列表，用户的身份只能在身份列表的包含范围内选择；而 MSP 是接受身份供应商，会提供一个列表来确定哪些身份是可信的成员（也就是参与者）。</p>\n<h2 id=\"4-公钥基础结构pubic-key-infrastructure-pki\"><a class=\"markdownIt-Anchor\" href=\"#4-公钥基础结构pubic-key-infrastructure-pki\">#</a> 4. 公钥基础结构（Pubic Key Infrastructure, PKI）</h2>\n<p>PKI 有四个关键要素：数字证书 / 公钥私钥 / 证书颁发机构和证书撤销列表：</p>\n<p>数字证书包含了证书持有者（区块链网络参与者）的相关属性，其中最常见的证书类型就是 X.509 标准。最关键的是，证书持有者的公钥会在其证书中分发。数字签名可以验证消息的来源以及消息的完整性。</p>\n<p>公钥私钥的作用是为了验证数字签名（如 Fig 1），这里用到了我们常说的非对称加密。密钥之间唯一的数学关系使得私钥在消息上的签名只有对应的公钥在相同的消息上才能匹配。参与者用私钥加密，而任何持有其公钥的用户都可以查看签名消息并验证签名。其中的公钥是每一个节点都可以使用的，用于充当授权锚；私钥被用在消息中产生数字签名。消息的接收者可以通过其所持有的发送者的公钥来验证数字签名的有效性，进而验证消息的来源和完整性。</p>\n<p><img data-src=\"https://pic3.zhimg.com/80/v2-204c5b09ffdc82bf4612f31d7ee4be0a_1440w.webp\" alt=\"img\"></p>\n<p>Fig 1 数字签名</p>\n<p>证书颁发机构（Certificate Authority，CA）</p>\n<p>CA 是一个区块链网络信任的权威机构，它可以向参与者或者节点颁发经过加密验证的数字证书。CA 向不同的参与者颁发证书，并对这些证书进行签名，将参与者的公钥绑定上去（可以选择包含参与者全部属性的列表）。区块链网络中的成员信任 CA（并知道 CA 的公钥），则可以信任经过 CA 认证的证书，并通过验证 CA 的签名来获得签名中包含的所有属性。数字证书可以作为信任锚，来验证不同参与者的消息。区块链网络中可以存在一个或多个 CA。</p>\n<p>CA 分为根 CA 和中间 CA，它们构成了一条信任链。根 CA 能够给整个网络中的用户颁发证书，中间 CA 的证书直接或间接地由根 CA 颁发，可以有隐藏和保护根 CA 的作用。</p>\n<p>Fabric CA 是一个内置的 CA 组建，用来给 fabric 网络充当根 CA，提供和管理证书。</p>\n<p>证书吊销列表（Certificate Revocation Lists，CRL）是一个被吊销证书的黑名单，CRL 上的证书都将被视为无效。</p>\n<h2 id=\"5-成员服务提供者membership-service-provider-msp\"><a class=\"markdownIt-Anchor\" href=\"#5-成员服务提供者membership-service-provider-msp\">#</a> 5. 成员服务提供者（Membership Service Provider， MSP）</h2>\n<p>PKI 解决了 fabric 网络中身份发放的问题，但由于节点的私钥永远都不会公开，因此还需要引入一种可以证实身份的机制 MSP 。</p>\n<p>MSP 是一组被添加在网络中的配置文件夹，被用来在外部和内部定义组织（organization）。CA 生成代表身份的证书，而 MSP 包含了被许可身份的列表。MSP 通过识别成员或向成员颁发身份的 CA，来确定是否接受它们作为信任域的成员。MSP 通过标志参与者在节点或通道中的特定权利，将身份转化为角色。<strong>简而言之，PKI（具体说是 CA）提供的是身份；而 MSP 提供的是角色</strong>。</p>\n<p>当用户使用 Fabric CA 注册时，其必须关联为管理员 /peer 节点 / 客户端 / 排序节点 / 成员其中之一的角色。MSP 根据作用范围的不同分为：本地 MSP 和通道 MSP。本地 MSP 为客户端 /peer 节点 / 排序节点定义，每一个节点都必须定义一个本地 MSP。通道 MSP 则在通道层面定义了管理权和参与权，在通道中分配成员的权限，每一个参与通道的组织都要为自己定义一个通道 MSP。</p>\n<p>因此，MSP 是一种能使参与者加入联盟链的机制，想要在 Fabric 网络上进行交易需要：</p>\n<p>1. 拥有一个 CA 颁发的身份；2. 成为一个被网络中的成员认可的组织成员（将成员的公钥添加到组织的 MSP 中即可）；3. 将 MSP 添加到一个网络中的联盟或通道中；4. 确保 MSP 包含在网络所定义的策略（Policy）中。</p>\n<h2 id=\"6-策略policy\"><a class=\"markdownIt-Anchor\" href=\"#6-策略policy\">#</a> 6. 策略（Policy）</h2>\n<p>在 Fabric 中，策略是基础设施的管理机制。它表示了成员如何同意或拒绝网络 / 通道 / 智能合约的更改。策略是在区块链网络最初配置时由联盟成员一致同意的，但在网络演化的过程中可以更改。简而言之，在区块链网络中的所有行为都要受到策略的控制。</p>\n<p>策略是 Fabirc 区别于公链的内容之一。在公链中，交易可以在网络中的任意节点中生成和验证，但是 Fabric 是许可链的一种，因此策略决定了哪些组织可以访问或更新 Fabric 网络，并且提供了强制执行这些决策的机制。从这个角度看，我认为 Fabric 的可监管性更强。</p>\n<p>策略在 Fabric 网络的不同层级中都有应用。至于具体应用和访问控制列表（Access Control List，ACL）就放在后面再学了，这部分我感觉更偏向与工程实践。</p>\n<p>另外专门说两个我认为比较关键的策略：背书策略（Endorsement policy）定义了必须为执行提案背书的组织；修改策略（Modification policy）指定了任何配置更新所需要的一组身份，是更新策略的策略，每一个通道配置中都包含一个对修改策略的引用。</p>\n",
            "tags": [
                "区块链"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/02/28/C/C%E8%AF%AD%E8%A8%80%E9%97%AE%E9%A2%98/",
            "url": "https://ashgen.gitee.io/2023/02/28/C/C%E8%AF%AD%E8%A8%80%E9%97%AE%E9%A2%98/",
            "title": "C语言问题",
            "date_published": "2023-02-28T09:00:00.000Z",
            "content_html": "<h1 id=\"数组名取地址a\"><a class=\"markdownIt-Anchor\" href=\"#数组名取地址a\">#</a> 数组名取地址 &amp; a</h1>\n<p>a 是一个数组名，对于一个普通的变量 b，&amp;b 是指用取地址符号取得变量 b 的存放地址；a 在内存中没有分配空间，只对数组 a 的各个元素分配了存储空间，此处数组名字 a 显然不是普通的变量，&amp;a 也不代表所取 a 的存储地址。</p>\n<p><strong>&amp;a 在数值上等于 &amp; a [0]，也等于 a。<strong>此时，&amp;a 数值上等于整个数组的起始位置地址，含义上代表整个数组所占内存的大小，因为它的</strong>进阶单位是整个数组的字节长度</strong>，（&amp;a + 1）等于的是数组结束之后的下一段的起始位置地址。</p>\n",
            "tags": [
                "细节问题"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/02/27/python/anaconda%E7%8E%AF%E5%A2%83/",
            "url": "https://ashgen.gitee.io/2023/02/27/python/anaconda%E7%8E%AF%E5%A2%83/",
            "title": "python环境配置",
            "date_published": "2023-02-27T13:46:25.000Z",
            "content_html": "<h1 id=\"anaconda装完后pip无法使用的问题\"><a class=\"markdownIt-Anchor\" href=\"#anaconda装完后pip无法使用的问题\">#</a> anaconda 装完后，pip 无法使用的问题</h1>\n<p>系统的环境变量的 path 中，</p>\n<p>D:Anaconda3</p>\n<p>D:Anaconda3\\Library\\bin</p>\n<p>D:Anaconda3\\Scripts</p>\n<p>均要添加</p>\n",
            "tags": [
                "环境"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/02/26/%E7%BD%91%E5%9D%80%E6%8E%A8%E8%8D%90/%E5%AD%A6%E4%B9%A0%E7%BD%91%E5%9D%80%E5%AF%BC%E8%88%AA/",
            "url": "https://ashgen.gitee.io/2023/02/26/%E7%BD%91%E5%9D%80%E6%8E%A8%E8%8D%90/%E5%AD%A6%E4%B9%A0%E7%BD%91%E5%9D%80%E5%AF%BC%E8%88%AA/",
            "title": "网址导航",
            "date_published": "2023-02-26T06:26:08.234Z",
            "content_html": "<h1 id=\"编程语言\"><a class=\"markdownIt-Anchor\" href=\"#编程语言\">#</a> 编程语言</h1>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWM0NDExZTc3dA==\">Python 基础 (小甲鱼 - 新版)</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWV0NDExYjczWi8=\">黑马程序员 C++ 教程</span></li>\n<li></li>\n</ul>\n<h1 id=\"sketchup模型获取\"><a class=\"markdownIt-Anchor\" href=\"#sketchup模型获取\">#</a> sketchup 模型获取</h1>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuM2Q2Ni5jb20v\">3D 溜溜网</span></li>\n<li></li>\n</ul>\n<h1 id=\"unity3d模型获取\"><a class=\"markdownIt-Anchor\" href=\"#unity3d模型获取\">#</a> Unity3D 模型获取</h1>\n<ul>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYWlnZWkuY29tL3VuaXR5M2QvbW9kZWwv\">爱给网</span></li>\n<li><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuM2Q2Ni5jb20v\">3D 溜溜网</span></li>\n</ul>\n",
            "tags": [
                "网址"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/02/26/%E7%94%9F%E6%B4%BB/%E5%8C%97%E4%BA%AC%E6%B8%B8%E7%8E%A9%E6%94%BB%E7%95%A5/",
            "url": "https://ashgen.gitee.io/2023/02/26/%E7%94%9F%E6%B4%BB/%E5%8C%97%E4%BA%AC%E6%B8%B8%E7%8E%A9%E6%94%BB%E7%95%A5/",
            "title": "北京游玩攻略",
            "date_published": "2023-02-25T16:16:12.864Z",
            "content_html": "<h1 id=\"吃\"><a class=\"markdownIt-Anchor\" href=\"#吃\">#</a> 吃</h1>\n<p>牛街                 西城区约 2 小时</p>\n<p>王府井               东城区约 2 小时</p>\n<p>前门大栅栏           西城区约 2 小时</p>\n<p>南锣鼓巷             东城区约 2 小时</p>\n<p>合生汇               朝阳区约两小时 20 分</p>\n<h1 id=\"逛街\"><a class=\"markdownIt-Anchor\" href=\"#逛街\">#</a> 逛街</h1>\n<p>三里屯太古里         朝阳区约 2 小时</p>\n<p>朝阳大悦城           朝阳区约 2 小时 20 分</p>\n<p>侨福芳草地           朝阳区约 2 小时</p>\n<p>八达岭奥特莱斯       昌平区约 40 分钟</p>\n<h1 id=\"著名景点\"><a class=\"markdownIt-Anchor\" href=\"#著名景点\">#</a> 著名景点</h1>\n<p>故宫博物院           东城区约 2 小时                   20-40 / 人          08:30 开园</p>\n<p>颐和园               海淀区约 1 小时 40 分              10-20 / 人          06:30 开园</p>\n<p>天安门               东城区约 2 小时 05:15-18:00        网上预约</p>\n<p>天坛                 东城区约 2 小时 10 分              28 / 人            06:30 开园</p>\n<p>十三陵               昌平区约 1 小时 10 分              93 / 人            09:00-16:00</p>\n<p>恭王府               西城区约 1 小时 40 分              学生半价</p>\n<p>鸟巢                 朝阳区约 2 小时                   98 / 人            09:00-18:30</p>\n<p>香山                 海淀区约 2 小时 20 分              10 / 人            06:00 开园</p>\n<p>八达岭野生动物世界  延庆区约 1 小时 20 分              43 / 人 (83)        08:30 开园</p>\n<p>八达岭长城 + 夜场      延庆区约 1 小 30 分                17.5 / 人 (35)       07:30 开园</p>\n<p>居庸关长城           昌平区约 1 小时                   17.5 / 人 (35)       08:30-16:30</p>\n<p>雁栖湖               怀柔区约 3 小时                   10 / 人 (20)        08:30 开园</p>\n<h1 id=\"寺庙\"><a class=\"markdownIt-Anchor\" href=\"#寺庙\">#</a> 寺庙</h1>\n<p>雍和宫               东城区约 1 小时 40 分              网上购票        09:00 开园</p>\n<p>红螺寺               怀柔区约 3 小时                   27 / 人 (54)        08:30 开园</p>\n<p>潭柘寺               门头沟区约 3 小时                 24 / 人 (49)        08:30 开园</p>\n<h1 id=\"各种馆\"><a class=\"markdownIt-Anchor\" href=\"#各种馆\">#</a> 各种馆</h1>\n<p>中国科学技术馆       朝阳区约 2 小时 20 分              116 / 人 (126)      09:30 开园</p>\n<p>天文馆               西城区约 2 小时                   79 / 人 (88)        09:00 开园</p>\n<p>海洋馆               海淀区约 2 小时                   83 起 / 人         10:00 开园</p>\n<h1 id=\"玩\"><a class=\"markdownIt-Anchor\" href=\"#玩\">#</a> 玩</h1>\n<p>北京环球影城         通州区约两个半小时           378-413 / 人       10:00-19:00</p>\n<p>北京欢乐谷           朝阳区约两个半小时           295 / 人           10:00 开园</p>\n<p>失重星球乐园（欢乐谷店）约两个半小时             97 / 人            10:00-18:00</p>\n<p>Super rabbit 运动会    昌平区约一个半小时          106 / 人          10:00-21:00</p>\n<p>新港卡丁车俱乐部（奥森店）朝阳区                118 / 人 (108)      09:00-22:00</p>\n<h1 id=\"感谢橘子先生的投稿\"><a class=\"markdownIt-Anchor\" href=\"#感谢橘子先生的投稿\">#</a> 感谢<a href> @橘子先生</a>的投稿</h1>\n",
            "tags": [
                "玩"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/02/25/sketchup/sketchup%E5%AF%BC%E5%85%A5Unity3d/",
            "url": "https://ashgen.gitee.io/2023/02/25/sketchup/sketchup%E5%AF%BC%E5%85%A5Unity3d/",
            "title": "sketchup导入Unity3d",
            "date_published": "2023-02-25T12:46:25.000Z",
            "content_html": "<ol>\n<li>新建 SketchUp 工程的时候，选择工程单位为 Meter (米)，如果不是米，则在 Tools -&gt; Model Info -&gt; Unit 内将 Format 修改为 Decimal : Meters 即可。因为会影响到 SketchUp 的原图，所以请注意如果精度不够的话还需要把 Precision 变更为足够的精度，把 Enable length snapping 也设置为和精度一致使其能够正确的执行自动捕捉。</li>\n<li>导出时注意选择参数，请选择 File -&gt; Export -&gt; 3D Model 里面有 FBX 这个格式（好像只有 Pro 版本的 SketchUp 才行哦），先不要着急 Export，选择一下 Options 修改几个选项，Export Options 中的<br>\n选中 Triangulate all faces 将所有面变为三角形构成的<br>\n选中 Export two-sided faces 将双面都导出（有的平面两面材质不同的，这很重要）<br>\n选中 Export texture maps 导出贴图表面<br>\n选中 Swap YZ coordinates（Y 朝上）<br>\n单位选择 Model Unit（如果你第一步是对的，这里选 Meters 也是一样的效果）</li>\n<li>在 Unity3D 中选择 Asserts -&gt; Import New Asset，找到刚刚导出的 fbx 文件，选中，文件导入成功后选择 Project 窗口中的模型，然后将其 Inspector 中的 (FBXImporter) -&gt; Meshes -&gt; Scale Factor（缩放比例）修改为 1。最后将模型拖入场景子级就大功告成啦。</li>\n</ol>\n",
            "tags": [
                "3d建模"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/02/24/sketchup/sketchup%E5%AF%BC%E5%85%A53dsmax/",
            "url": "https://ashgen.gitee.io/2023/02/24/sketchup/sketchup%E5%AF%BC%E5%85%A53dsmax/",
            "title": "sketchup导入3dsmax",
            "date_published": "2023-02-24T12:46:25.000Z",
            "content_html": "<p>sketchup——》unity3d 丢失模型贴图问题解决：打开 su 模型，文件→另存为→保存文件类型下拉另存为 8 版本<img data-src=\"sketchup%E5%AF%BC%E5%85%A53dsmax/image-20230225153742223.png\" alt=\"image-20230225153742223\"></p>\n",
            "tags": [
                "3d建模"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/02/24/shoka%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/%E5%86%99%E5%8D%9A%E5%AE%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/",
            "url": "https://ashgen.gitee.io/2023/02/24/shoka%E5%8D%9A%E5%AE%A2%E4%B8%BB%E9%A2%98/%E5%86%99%E5%8D%9A%E5%AE%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/",
            "title": "本站自身建设",
            "date_published": "2023-02-24T12:46:25.000Z",
            "content_html": "<h1 id=\"写博客注意事项\"><a class=\"markdownIt-Anchor\" href=\"#写博客注意事项\">#</a> 写博客注意事项</h1>\n<ol>\n<li>\n<p>在博客的开头，使用 YAML Font Matter 包围以下文字</p>\n<figure class=\"highlight html\"><figcaption data-lang=\"HTML\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre>title: XXX</pre></td></tr><tr><td data-num=\"2\"></td><td><pre></pre></td></tr><tr><td data-num=\"3\"></td><td><pre>date: 2023/02/24 20:46:25 </pre></td></tr><tr><td data-num=\"4\"></td><td><pre></pre></td></tr><tr><td data-num=\"5\"></td><td><pre>categories: </pre></td></tr><tr><td data-num=\"6\"></td><td><pre></pre></td></tr><tr><td data-num=\"7\"></td><td><pre>- XXX </pre></td></tr><tr><td data-num=\"8\"></td><td><pre></pre></td></tr><tr><td data-num=\"9\"></td><td><pre>tags: </pre></td></tr><tr><td data-num=\"10\"></td><td><pre></pre></td></tr><tr><td data-num=\"11\"></td><td><pre>- XXX</pre></td></tr></table></figure></li>\n<li>\n<p><strong>不能直接把网址放到文章中，要加超链接</strong></p>\n</li>\n<li>\n<p>文章首页分类时，分类标题不能有字符，只能是英文和汉字</p>\n</li>\n</ol>\n<h1 id=\"上传图片至本博客的图床中\"><a class=\"markdownIt-Anchor\" href=\"#上传图片至本博客的图床中\">#</a> 上传图片至本博客的图床中</h1>\n<p>首先进入 https://smms.app/，</p>\n<p><img data-src=\"%E5%86%99%E5%8D%9A%E5%AE%A2%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/image-20230311173825147-16852626113381.png\" alt=\"image-20230311173825147\"> 然后上传图片之后复制进 D:\\myblog\\themes\\shoka_images.yml 文件中，按照上面格式添加即可。</p>\n",
            "tags": [
                "博客"
            ]
        },
        {
            "id": "https://ashgen.gitee.io/2023/02/24/%E5%AE%9E%E4%B9%A0/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/",
            "url": "https://ashgen.gitee.io/2023/02/24/%E5%AE%9E%E4%B9%A0/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/",
            "title": "实习面试问题",
            "date_published": "2023-02-24T12:46:25.000Z",
            "content_html": "<h1 id=\"如何判断一个链表有无环\"><a class=\"markdownIt-Anchor\" href=\"#如何判断一个链表有无环\">#</a> 如何判断一个链表有无环</h1>\n<h1 id=\"二叉树的遍历方式\"><a class=\"markdownIt-Anchor\" href=\"#二叉树的遍历方式\">#</a> 二叉树的遍历方式</h1>\n<h1 id=\"快速排序与冒泡排序的比较\"><a class=\"markdownIt-Anchor\" href=\"#快速排序与冒泡排序的比较\">#</a> 快速排序与冒泡排序的比较</h1>\n",
            "tags": [
                "实习"
            ]
        }
    ]
}