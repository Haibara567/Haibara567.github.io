{
    "version": "https://jsonfeed.org/version/1",
    "title": "寻找未曾见过的你 • All posts by \"xxx\" tag",
    "description": "吉兆要出现三次，幸运才会降临；谢幕时应当三次鞠躬；而在风来人的剑斗剧中，胜负的对手也有三名。",
    "home_page_url": "https://haibara567.github.io",
    "items": [
        {
            "id": "https://haibara567.github.io/2023/03/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%AC%E4%B8%89%E7%AB%A0/",
            "url": "https://haibara567.github.io/2023/03/17/%E6%95%B0%E6%8D%AE%E5%BA%93/%E7%AC%AC%E4%B8%89%E7%AB%A0/",
            "title": "第三章",
            "date_published": "2023-03-17T14:13:25.000Z",
            "content_html": "<h1 id=\"完整性约束的三个子句\"><a class=\"markdownIt-Anchor\" href=\"#完整性约束的三个子句\">#</a> 完整性约束的三个子句</h1>\n<ul>\n<li><strong>主键子句：Primary Key</strong></li>\n</ul>\n<p>体现实体完整性：取值非空、唯一</p>\n<ul>\n<li><strong>外键子句: Foreign Key</strong></li>\n</ul>\n<p>体现参照完整性: References 指出所对应的列名</p>\n<ul>\n<li><strong>检查子句：Check</strong></li>\n</ul>\n<p>用户自定义完整性：指出取值的具体要求</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">select</span> <span class=\"token keyword\">DISTINCT</span> Sno <span class=\"token keyword\">From</span> SC</pre></td></tr></table></figure><p>DISTINCT 的作用是删除重复值</p>\n<figure class=\"highlight sql\"><figcaption data-lang=\"SQL\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token keyword\">Select</span> sno</pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token keyword\">From</span> SC</pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">Group</span> <span class=\"token keyword\">by</span> sno</pre></td></tr><tr><td data-num=\"4\"></td><td><pre><span class=\"token keyword\">Having</span> <span class=\"token function\">count</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span><span class=\"token operator\">></span><span class=\"token number\">3</span></pre></td></tr></table></figure><p>where 与 having 的区别在于作用对象不同 where 作用于基本表或视图，选出满足条件的元组；having 作用于组，选择满足条件的组。</p>\n",
            "tags": [
                "XXX"
            ]
        },
        {
            "id": "https://haibara567.github.io/2023/03/17/C/C++%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/",
            "url": "https://haibara567.github.io/2023/03/17/C/C++%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/",
            "title": "C++实用函数",
            "date_published": "2023-03-17T08:18:25.000Z",
            "content_html": "<h1 id=\"strtok\"><a class=\"markdownIt-Anchor\" href=\"#strtok\">#</a> strtok()</h1>\n<h2 id=\"描述\"><a class=\"markdownIt-Anchor\" href=\"#描述\">#</a> 描述</h2>\n<p>C 库函数 <strong>char *strtok(char *str, const char *delim)</strong> 分解字符串 <strong>str</strong> 为一组字符串，<strong>delim</strong> 为分隔符。</p>\n<h2 id=\"声明\"><a class=\"markdownIt-Anchor\" href=\"#声明\">#</a> 声明</h2>\n<p>下面是 strtok () 函数的声明。</p>\n<pre><code>char *strtok(char *str, const char *delim)\n</code></pre>\n<h2 id=\"参数\"><a class=\"markdownIt-Anchor\" href=\"#参数\">#</a> 参数</h2>\n<ul>\n<li><strong>str</strong> – 要被分解成一组小字符串的字符串。</li>\n<li><strong>delim</strong> – 包含分隔符的 C 字符串。</li>\n</ul>\n<h2 id=\"返回值\"><a class=\"markdownIt-Anchor\" href=\"#返回值\">#</a> 返回值</h2>\n<p>该函数返回被分解的第一个子字符串，如果没有可检索的字符串，则返回一个空指针。</p>\n<h2 id=\"实例\"><a class=\"markdownIt-Anchor\" href=\"#实例\">#</a> 实例</h2>\n<p>下面的实例演示了 strtok () 函数的用法。</p>\n<h2 id=\"实例-2\"><a class=\"markdownIt-Anchor\" href=\"#实例-2\">#</a> 实例</h2>\n<figure class=\"highlight c\"><figcaption data-lang=\"c\"></figcaption><table><tr><td data-num=\"1\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;string.h></span> </span></pre></td></tr><tr><td data-num=\"2\"></td><td><pre><span class=\"token macro property\"><span class=\"token directive-hash\">#</span><span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;stdio.h></span>  </span></pre></td></tr><tr><td data-num=\"3\"></td><td><pre><span class=\"token keyword\">int</span> <span class=\"token function\">main</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>   </pre></td></tr><tr><td data-num=\"4\"></td><td><pre>    <span class=\"token keyword\">char</span> str<span class=\"token punctuation\">[</span><span class=\"token number\">80</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"This is - www.runoob.com - website\"</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"5\"></td><td><pre>    <span class=\"token keyword\">const</span> <span class=\"token keyword\">char</span> s<span class=\"token punctuation\">[</span><span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"-\"</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"6\"></td><td><pre>    <span class=\"token keyword\">char</span> <span class=\"token operator\">*</span>token<span class=\"token punctuation\">;</span>      <span class=\"token comment\">/* 获取第一个子字符串 */</span>   </pre></td></tr><tr><td data-num=\"7\"></td><td><pre>    token <span class=\"token operator\">=</span> <span class=\"token function\">strtok</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>      <span class=\"token comment\">/* 继续获取其他的子字符串 */</span>   </pre></td></tr><tr><td data-num=\"8\"></td><td><pre>    <span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span> token <span class=\"token operator\">!=</span> <span class=\"token constant\">NULL</span> <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>      </pre></td></tr><tr><td data-num=\"9\"></td><td><pre>        <span class=\"token function\">printf</span><span class=\"token punctuation\">(</span> <span class=\"token string\">\"%s\\n\"</span><span class=\"token punctuation\">,</span> token <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>          </pre></td></tr><tr><td data-num=\"10\"></td><td><pre>        token <span class=\"token operator\">=</span> <span class=\"token function\">strtok</span><span class=\"token punctuation\">(</span><span class=\"token constant\">NULL</span><span class=\"token punctuation\">,</span> s<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   </pre></td></tr><tr><td data-num=\"11\"></td><td><pre>    <span class=\"token punctuation\">&#125;</span>      </pre></td></tr><tr><td data-num=\"12\"></td><td><pre>    <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> </pre></td></tr><tr><td data-num=\"13\"></td><td><pre><span class=\"token punctuation\">&#125;</span></pre></td></tr></table></figure><p>让我们编译并运行上面的程序，这将产生以下结果：</p>\n<pre><code>This is \n www.runoob.com \n website\n</code></pre>\n<h1 id=\"string中c_str-data-copypn函数的用法\"><a class=\"markdownIt-Anchor\" href=\"#string中c_str-data-copypn函数的用法\">#</a> string 中 c_str ()、data ()、copy (p,n) 函数的用法</h1>\n<p>标准库的 string 类提供了 3 个成员函数来从一个 string 得到 c 类型的字符数组：c_str ()、data ()、copy (p,n)。</p>\n<h2 id=\"c_str生成一个const-char指针指向以空字符终止的数组\"><a class=\"markdownIt-Anchor\" href=\"#c_str生成一个const-char指针指向以空字符终止的数组\">#</a> c_str ()：生成一个 const char * 指针，指向以空字符终止的数组。</h2>\n<p>①这个数组的数据是临时的，当有一个改变这些数据的成员函数被调用后，其中的数据就会失效。因此要么现用先转换，要么把它的数据复制到用户自己可以管理的内存中。注意。看下例：</p>\n<pre><code class=\"language-c++\">const char* c;\nstring s=&quot;1234&quot;;\nc = s.c_str(); \ncout&lt;&lt;c&lt;&lt;endl; //输出：1234\ns=&quot;abcd&quot;;\ncout&lt;&lt;c&lt;&lt;endl; //输出：abcd\n</code></pre>\n<p>上面如果继续用 c 指针的话，导致的错误将是不可想象的。就如：1234 变为 abcd</p>\n<p>其实上面的 c = s.c_str (); 不是一个好习惯。既然 c 指针指向的内容容易失效，我们就应该按照上面的方法，那怎么把数据复制出来呢？这就要用到 strcpy 等函数（推荐）。</p>\n<pre><code class=\"language-c++\">//const char* c; //①\n//char* c;       //②\n//char c[20]; \nchar* c=new char[20];\nstring s=&quot;1234&quot;;\n//c = s.c_str(); \nstrcpy(c,s.c_str());\ncout&lt;&lt;c&lt;&lt;endl; //输出：1234\ns=&quot;abcd&quot;;\ncout&lt;&lt;c&lt;&lt;endl; //输出：1234\n</code></pre>\n<p>注意：不能再像上面一样①所示了，const 还怎么向里面写入值啊；也不能②所示，使用了未初始化的局部变量 “c”，运行会出错的 。</p>\n<p>② c_str () 返回一个客户程序可读不可改的指向字符数组的指针，不需要手动释放或删除这个指针。</p>\n<p><strong>data (): 与 c_str () 类似，但是返回的数组不以空字符终止。</strong></p>\n<h1 id=\"sort\"><a class=\"markdownIt-Anchor\" href=\"#sort\">#</a> sort()</h1>\n<p>对指定范围内元素进行快速排序</p>\n<p>sort 是 STL 自带的系统函数，它的格式是：</p>\n<p>void sort (要排序元素的起始地址，要排序元素的结束地址，比较函数)；</p>\n<p>这里可以省略比较函数，他是默认从小到大排序的（升序排序）</p>\n<pre><code class=\"language-c++\">#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n&#123;\n\tint a[]=&#123;3,5,2,6,9,3,5&#125;;\n\tsort(a,a+7);//7是数组的元素个数，这里a为数组的开头，a+7就等于排序到数组的第七个元素\n\tfor(int i=0;i&lt;6;i++)\n\t\tcout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;\n&#125;\n</code></pre>\n<p>输出:</p>\n<p>2 3 3 5 5 6</p>\n<p>void sort (要排序元素的起始地址，要排序元素的结束地址，比较函数)；</p>\n<p>这个比较函数的作用就是可以自定义排序方式，比如降序排序。</p>\n<p>定义：bool cmp (int x,int y)…，如果返回 True 那么 x 就排在 y 前面。</p>\n<pre><code class=\"language-c++\">#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nbool cmp(int x,int y)\n&#123;\n\tif(x&gt;y)return true;//降序\n\treturn false;\n&#125;\nint main()\n&#123;\n\tint a[]=&#123;3,5,2,6,9,3,5&#125;;\n\tsort(a,a+7,cmp);//7是数组的元素个数\n\tfor(int i=0;i&lt;6;i++)\n\t\tcout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;\n&#125;\n</code></pre>\n<p>输出：</p>\n<p>9 6 5 5 3 3</p>\n<h1 id=\"map\"><a class=\"markdownIt-Anchor\" href=\"#map\">#</a> Map</h1>\n<p>map 是 STL 的一个关联容器，它提供一对一的 hash。</p>\n<p>第一个可以称为关键字 (key)，每个关键字只能在 map 中出现一次；<br>\n第二个可能称为该关键字的值 (value)；<br>\n定义：<br>\nmap &lt;类型，类型&gt; m;<br>\n 举个栗子:<br>\n 记录每个人的名字的对应的爱好，张三喜欢吃汉堡：</p>\n<pre><code class=\"language-c++\">#include&lt;map&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nint main()\n&#123;\n\tmap&lt;string,string&gt; m;\n\tm[&quot;张三&quot;]=&quot;吃汉堡&quot;;\n\tcout&lt;&lt;&quot;张三: &quot;&lt;&lt;m[&quot;张三&quot;]; \n&#125;\n</code></pre>\n<p>输出：</p>\n<p>张三：吃汉堡</p>\n<h1 id=\"stack栈\"><a class=\"markdownIt-Anchor\" href=\"#stack栈\">#</a> stack (栈)</h1>\n<p>头文件:</p>\n<p>#include<stack><br>\nstack 好像还有个翻译叫 “咸鱼”… 嘿嘿。</stack></p>\n<p>栈的介绍：<br>\n栈就像一个盒子，可以放入或去除元素，但是个人类都知道，要把盒子底下的东西取出来，就必须先取出他上面的东西。</p>\n<p>假如我们把 1、2、3、4、5 按顺序分别入栈：</p>\n<p>栈的定义：<br>\nstack &lt;类型 (可以不写)&gt; st;<br>\n 或者 stack st;<br>\n 很 easy 是不？</p>\n<p>栈的成员函数：<br>\n.empty ()\t判断栈是否为空，空则返回 true<br>\n.pop ()\t移除栈顶元素<br>\n.push (啥啥啥)\t在栈顶增加元素<br>\n.size ()\t返回栈中元素数目<br>\n.top ()\t返回栈顶元素<br>\n.empty ()  判断栈是否为空。</p>\n<pre><code class=\"language-c++\">stack st;\nif(st.empty())//如果是空那么执行下面代码\n    ......\n</code></pre>\n<p>.push (啥啥啥), 在栈顶增加元素。</p>\n<p>.top ()，返回栈顶元素，记住是返回，要单独输出。</p>\n<pre><code class=\"language-c++\">#include&lt;stack&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nstack&lt;int&gt; st;\nint main()&#123;\n    st.push(5418);\n    cout&lt;&lt;st.top();//输出栈顶元素\n    return 0;\n\n&#125;\n</code></pre>\n<p>输出 5418。</p>\n<p>​</p>\n<p>.size (), 返回栈中元素数目。</p>\n<pre><code class=\"language-c++\">#include&lt;stack&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nstack&lt;int&gt; st;\nint main()&#123;\n    st.push(5418);\n    cout&lt;&lt;st.size();\n    return 0;\n&#125;\n</code></pre>\n<p>输出 1</p>\n<p>.pop ()，移除栈顶元素：</p>\n<pre><code class=\"language-c++\">#include&lt;stack&gt;\n#include&lt;iostream&gt;\nusing namespace std;\nstack&lt;int&gt; st;\nint main()&#123;\n    \n\n    st.push(1452);\n    st.push(5418);\n    st.pop();\n    cout&lt;&lt;st.top();\n    \n    return 0;\n\n&#125;\n</code></pre>\n<p>输出 1452。</p>\n<p>简单不？</p>\n<h1 id=\"二分查找\"><a class=\"markdownIt-Anchor\" href=\"#二分查找\">#</a> 二分查找</h1>\n<p>头文件：</p>\n<pre><code class=\"language-c++\">#include &lt;algorithm&gt;\n</code></pre>\n<p>美妙的函数：</p>\n<h2 id=\"1lower_bound函数\"><a class=\"markdownIt-Anchor\" href=\"#1lower_bound函数\">#</a> 1.lower_bound 函数</h2>\n<p>对于有序容器，有序容器，有序容器（重要的事情说三遍）快速二分查找出第一个大于等于</p>\n<p>指定数的位置（下标），如果没有找到，返回最后一个数据后面的位置。</p>\n<p>对于数组，通常的格式为：</p>\n<p>查找的数组下标 = lower_bound (数组要查找的开始位置，数组要查找的结束位置后面，要找的数) – 数组开始位置 (一般写数组名);</p>\n<p>比如：</p>\n<pre><code class=\"language-c++\">#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\n\nusing namespace std;\n\nint main() &#123;\n\n    int a[5] = &#123; 1,2,3,3,8 &#125;;\n     \n    //从 a 数组中找到第一个不小于   3 的元素\n     \n    int   index = lower_bound(a, a + 5, 3)-a;//查找的数组下标 = lower_bound(数组要查找的开始位置，数组要查找的结束位置后面，要找的数) – 数组开始位置;\n     \n    if   (index==5 ) cout &lt;&lt; &quot; not found! &quot;;//index=5，也就是数组末尾的位置。\n    else  cout &lt;&lt; index;\n     \n    return   0;\n\n&#125;\n</code></pre>\n<p>输出 2。</p>\n<h2 id=\"2upper_bound函数\"><a class=\"markdownIt-Anchor\" href=\"#2upper_bound函数\">#</a> 2.upper_bound 函数</h2>\n<p>有一个类似 lower_bound 的函数 upper_bound, 快速二分查找出第一个大于指定数的位置（下</p>\n<p>标），如果没有找到，返回最后一个数据后面的位置。</p>\n<p>举个栗子，啊… 快没栗子了。(っ °Д °;) っ</p>\n<pre><code class=\"language-c++\">#include&lt;algorithm&gt;\n#include&lt;iostream&gt;\n\nusing namespace std;\n\nint main() &#123;\n\n    int a[5] = &#123; 1,2,3,3,8 &#125;;\n    //从 a 数组中找到第一个大于 3 的元素\n     \n    int   index = upper_bound(a, a + 5, 3)-a;\n     \n    if   (index==5 ) cout &lt;&lt; &quot; not found! &quot;;\n    else cout &lt;&lt; index;\n     \n    return   0;\n\n&#125;\n</code></pre>\n<p>输出 4.</p>\n<h2 id=\"3binary_search查找数组内某个元素是否出现\"><a class=\"markdownIt-Anchor\" href=\"#3binary_search查找数组内某个元素是否出现\">#</a> 3.binary_search：查找数组内某个元素是否出现。</h2>\n<p>void binary_search (数组首地址，结束地址，要查找的数)</p>\n<p>返回值为 bool 类型，找到了返回 true。</p>\n",
            "tags": [
                "XXX"
            ]
        },
        {
            "id": "https://haibara567.github.io/2023/03/08/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/%E4%B8%93%E4%B8%9A%E9%97%AE%E9%A2%98/",
            "url": "https://haibara567.github.io/2023/03/08/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/%E4%B8%93%E4%B8%9A%E9%97%AE%E9%A2%98/",
            "title": "专业问题",
            "date_published": "2023-03-08T13:46:25.000Z",
            "content_html": "<h1 id=\"数据结构类\"><a class=\"markdownIt-Anchor\" href=\"#数据结构类\">#</a> 数据结构类</h1>\n<h2 id=\"b树和b树的区别\"><a class=\"markdownIt-Anchor\" href=\"#b树和b树的区别\">#</a> B 树和 B + 树的区别？</h2>\n<ul>\n<li>B 树在所有结点都存数据，B + 树只在叶子结点存数据</li>\n<li>B + 树支持遍历叶子结点，B 树不支持</li>\n</ul>\n<h2 id=\"说几种排序的算法\"><a class=\"markdownIt-Anchor\" href=\"#说几种排序的算法\">#</a> 说几种排序的算法</h2>\n<p>选择、冒泡、插入、快速、堆、归并排序</p>\n<h2 id=\"快速排序的思想\"><a class=\"markdownIt-Anchor\" href=\"#快速排序的思想\">#</a> 快速排序的思想？</h2>\n<h2 id=\"快速排序在数据基本有序的情况下时间复杂度会达到onn如何改进\"><a class=\"markdownIt-Anchor\" href=\"#快速排序在数据基本有序的情况下时间复杂度会达到onn如何改进\">#</a> 快速排序在数据基本有序的情况下时间复杂度会达到 O (n*n)，如何改进？</h2>\n<ul>\n<li>头、尾、中间三个元素取中间值作为基准元素</li>\n<li>在一次分割结束后，可以把与 Key 相等的元素聚在一起，继续下次分割时，不用再对与 key 相等元素分割</li>\n</ul>\n<h2 id=\"c中有拷贝构造函数什么时候需要重写拷贝构造函数\"><a class=\"markdownIt-Anchor\" href=\"#c中有拷贝构造函数什么时候需要重写拷贝构造函数\">#</a> C++ 中有拷贝构造函数，什么时候需要重写拷贝构造函数？</h2>\n<p>拷贝构造函数是使用类对象的引用作为参数的构造函数，它能够将参数的属性值拷贝给新的对象，完成新对象的初始化。一般三种情况我们可能需要重写拷贝构造函数</p>\n<ol>\n<li>使用一个对象初始化另一个对象</li>\n<li>对象作为实参传递给参数</li>\n<li>函数返回值为类对象，创建临时对象作为返回值</li>\n</ol>\n<h2 id=\"什么是抽象类\"><a class=\"markdownIt-Anchor\" href=\"#什么是抽象类\">#</a> 什么是抽象类</h2>\n<p>如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。抽象类不能实例化对象，所以抽象类必须被继承，才能被使用</p>\n<h2 id=\"头指针和头结点的区别\"><a class=\"markdownIt-Anchor\" href=\"#头指针和头结点的区别\">#</a> 头指针和头结点的区别</h2>\n<p>头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针</p>\n<p>头结点是为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义</p>\n<h2 id=\"bfs和dfs的区别\"><a class=\"markdownIt-Anchor\" href=\"#bfs和dfs的区别\">#</a> BFS 和 DFS 的区别</h2>\n<p>DFS 使用栈，相当于二叉树的先序遍历</p>\n<p>BFS 使用队列，相当于二叉树的层序遍历</p>\n<h2 id=\"什么是稳定的排序算法\"><a class=\"markdownIt-Anchor\" href=\"#什么是稳定的排序算法\">#</a> 什么是稳定的排序算法</h2>\n<p>序列中，存在多个具有相同的关键字的记录，经过排序，这些记录的相对次序保持不变</p>\n<h2 id=\"堆排序的排序过程\"><a class=\"markdownIt-Anchor\" href=\"#堆排序的排序过程\">#</a> 堆排序的排序过程</h2>\n<h1 id=\"操作系统类\"><a class=\"markdownIt-Anchor\" href=\"#操作系统类\">#</a> 操作系统类</h1>\n<h2 id=\"进程的7个状态\"><a class=\"markdownIt-Anchor\" href=\"#进程的7个状态\">#</a> 进程的 7 个状态</h2>\n<p>创建、就绪、运行、阻塞、终止、就绪挂起、阻塞挂起</p>\n<h2 id=\"操作系统如何实现内存保护\"><a class=\"markdownIt-Anchor\" href=\"#操作系统如何实现内存保护\">#</a> 操作系统如何实现内存保护</h2>\n<ul>\n<li><strong>上、下限寄存器</strong></li>\n<li><strong>重定位寄存器</strong>和<strong>界地址寄存器</strong></li>\n</ul>\n<h2 id=\"进程控制块包含哪些信息\"><a class=\"markdownIt-Anchor\" href=\"#进程控制块包含哪些信息\">#</a> 进程控制块包含哪些信息</h2>\n<p><strong>进程标识、进程状态、优先级、中断现场、所占资源</strong></p>\n<h2 id=\"用户态和内核态之间的转换\"><a class=\"markdownIt-Anchor\" href=\"#用户态和内核态之间的转换\">#</a> 用户态和内核态之间的转换</h2>\n<p>用户态 ——&gt; 内核态：系统调用、中断、异常、主程序出错</p>\n<p>内核态 ——&gt; 用户态：使用修改 CPU 状态寄存器这一特权指令</p>\n<h2 id=\"中断和异常几种情况看一下\"><a class=\"markdownIt-Anchor\" href=\"#中断和异常几种情况看一下\">#</a> 中断和异常几种情况看一下</h2>\n<h1 id=\"数据库类\"><a class=\"markdownIt-Anchor\" href=\"#数据库类\">#</a> 数据库类</h1>\n<h2 id=\"mysql中的索引是用什么实现的\"><a class=\"markdownIt-Anchor\" href=\"#mysql中的索引是用什么实现的\">#</a> Mysql 中的索引是用什么实现的？</h2>\n<p>B 树和 B + 树</p>\n<h2 id=\"什么是数据库\"><a class=\"markdownIt-Anchor\" href=\"#什么是数据库\">#</a> 什么是数据库</h2>\n<p>按照数据结构来组织、存储和管理数据的仓库</p>\n<h2 id=\"数据库中索引的作用和优缺点\"><a class=\"markdownIt-Anchor\" href=\"#数据库中索引的作用和优缺点\">#</a> 数据库中索引的作用和优缺点</h2>\n<p>为了提高查询速度而对表字段附加的一种标识</p>\n<p>优点是能提高查询的速度</p>\n<p>缺点是会增大数据库的数据量</p>\n<h1 id=\"计算机网络类\"><a class=\"markdownIt-Anchor\" href=\"#计算机网络类\">#</a> 计算机网络类</h1>\n<h2 id=\"udp的主要特点\"><a class=\"markdownIt-Anchor\" href=\"#udp的主要特点\">#</a> UDP 的主要特点</h2>\n<p>无连接、尽最大努力交付、没有拥塞控制、首部开销小、支持一对多通信</p>\n<h1 id=\"神经网络类\"><a class=\"markdownIt-Anchor\" href=\"#神经网络类\">#</a> 神经网络类</h1>\n<h2 id=\"深度神经网络为什么要用非线性激活函数\"><a class=\"markdownIt-Anchor\" href=\"#深度神经网络为什么要用非线性激活函数\">#</a> 深度神经网络为什么要用非线性激活函数</h2>\n<p>如果不用激活函数，每一层输出都是上层输入的线性函数，很容易验证，无论你神经网络有多少层，输出都是输入的线性组合，与没有隐藏层效果相当</p>\n<h2 id=\"sigmoid激活函数和softmax激活函数的主要区别\"><a class=\"markdownIt-Anchor\" href=\"#sigmoid激活函数和softmax激活函数的主要区别\">#</a> sigmoid 激活函数和 softmax 激活函数的主要区别</h2>\n<p>softmax 的计算的是一个比重，而 sigmoid 只是对每一个输出值进行非线性化。</p>\n",
            "tags": [
                "XXX"
            ]
        },
        {
            "id": "https://haibara567.github.io/2023/03/08/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/%E8%8B%B1%E8%AF%AD%E9%97%AE%E9%A2%98/",
            "url": "https://haibara567.github.io/2023/03/08/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/%E8%8B%B1%E8%AF%AD%E9%97%AE%E9%A2%98/",
            "title": "英语问题",
            "date_published": "2023-03-08T13:46:25.000Z",
            "content_html": "<h1 id=\"自我介绍\"><a class=\"markdownIt-Anchor\" href=\"#自我介绍\">#</a> 自我介绍</h1>\n<p>Good morning. I am glad to be here for this interview. My name is Zhang YunFeng, 22. I come from Xuancheng City, the southeast of Anhui Province. I major in Computer Science and Technology at BeiJing Wuzi University and will graduate here in this coming June. （介绍自己）</p>\n<p>I am open-minded, quick in thought and very fond of new technology. Frequently I exchange with other people by making comments in the forum on line. I’m also with great perseverance. During the days preparing for the first postgraduate examination, I insist on playing badminton once a week. And just owning to this, I can be active and get along well with others. （基本优点 + 大学生活）</p>\n<p>After four year’s learning, I am deeply attracted by the dynamic and positive atmosphere of our major. So I hope to pursue advanced study to broaden my horizon. And I truly believe, I can be a better person after three year’s learning, of course, if I’m lucky enough to be admitted to the <strong>Beijing Institute of Technology</strong>**.** （报考学校的理由）</p>\n<p>I always believe that one will easily lag behind unless he keeps on learning. Therefore, During my postgraduate study, study and scientific research will be my first priority. I hope I can form a systematic view of computer science and technology and make a solid foundation for future study. I would be very honored if I can do any little contribution in this field. （生涯规划）</p>\n<p>That’s all about my self introduction, thank you!</p>\n<h1 id=\"introduce-my-hometown介绍家乡\"><a class=\"markdownIt-Anchor\" href=\"#introduce-my-hometown介绍家乡\">#</a> Introduce my hometown 介绍家乡</h1>\n<p>I am from a famous city with a long history over 2,000 years. It is called “Xuancheng ”. Xuancheng City is located in the southeast of Anhui Province. It is a thousand year county prefecture with a long history. It has been called Xuancheng County, Xuanzhou and Ningguo Prefecture successively. Known as “Xuancheng ancient poet land”, “Shangjiang humanities flourishing capital Xuancheng” said; Jingting Mountain is known as the “No.1 Poetry Mountain in the South of the Yangtze River”. I think the city really deserves it. Li Bai visited Xuancheng seven times and left more than 80 poems. Visitors at home and abroad feel it comfortable visiting here. There is my beloved hometown.</p>\n<h1 id=\"why-do-you-choose-to-further-study-instead-of-going-to-work-after-graduation为什么考研\"><a class=\"markdownIt-Anchor\" href=\"#why-do-you-choose-to-further-study-instead-of-going-to-work-after-graduation为什么考研\">#</a> Why do you choose to further study instead of going to work after graduation? 为什么考研？</h1>\n<p>Firstly, I am very interested in my major, and I think what I have learned during the undergraduate period is not deep enough. I want to learn more professional knowledge and further improve myself through the three-year postgraduate study.</p>\n<p>Then, my performance in the college entrance examination is not very ideal, and I want to be admitted to a better school to prove my ability</p>\n<p>In a word, I look forward to laying a solid foundation for my future career after completing my studies here.</p>\n<h1 id=\"introduce-your-favorite-sportintroduce-your-hobby\"><a class=\"markdownIt-Anchor\" href=\"#introduce-your-favorite-sportintroduce-your-hobby\">#</a> Introduce your favorite sport/Introduce your hobby</h1>\n<p>My favorite sport is playing badminton. Playing badminton needs the cooperation of eyes, hands and feet.During the days preparing for the first postgraduate examination, I insist on playing badminton once a week. Through playing badminton, I developed my team spirit and learned how to cooperate with others to win games. It also improves my communication skills, enables me to get a good interpersonal relationship, and can prevent myopia, which is also good for cervical spine.</p>\n<h1 id=\"introduce-my-family介绍家庭\"><a class=\"markdownIt-Anchor\" href=\"#introduce-my-family介绍家庭\">#</a> Introduce my family 介绍家庭</h1>\n<p>​    In my family, there are three members, my father, my mother and me. My parents are workers, my father works very hard, he is always busy, so most of the housework is done by my mother, of course, when I am at home, I will help her. When I make a success, they are more excited than me, and support me to do better. Even though I failed, instead of blaming, they always share sorrow with me, and encourage me not to give up. So I will do all what I can to repay them.</p>\n<h1 id=\"introduce-my-school介绍学校\"><a class=\"markdownIt-Anchor\" href=\"#introduce-my-school介绍学校\">#</a> Introduce my school 介绍学校</h1>\n<p>My university, Beijing Wuzi University, is located in Beijing, the capital of China. It is a university characterized by logistics and circulation, based on economics and centered on management. Founded in 1980, it has been subordinate to the State General Administration of Materials, the Ministry of Materials and the Ministry of Domestic Trade. The university offers 28 undergraduate programs and 17 authorized disciplines for master’s degrees. In April 2022, the Youth League Committee of Beijing Materials University was honored as the “Beijing May 4th Red Flag Youth League Committee”.</p>\n<p>我的学校是北京物资学院，坐落于中国首都北京市，是一所以物流和流通为特色，以经济学科为基础，以管理学科为主干的大学。它于 1980 年建校，先后隶属于国家物资总局、物资部、国内贸易部。学校开设 28 个本科专业，拥有 17 个硕士授权学科。2022 年 4 月，北京物资学院团委被表彰为 “北京市五四红旗团委”。</p>\n<h1 id=\"talk-about-your-favorite-courses谈谈你最喜欢的课程\"><a class=\"markdownIt-Anchor\" href=\"#talk-about-your-favorite-courses谈谈你最喜欢的课程\">#</a> Talk about your favorite courses 谈谈你最喜欢的课程</h1>\n<p>My favorite course is data structures. Data structure can let us understand the characteristics of computer processing objects, the actual problem involved in the processing objects expressed in the computer and to deal with them. At the same time, I also learned many commonly used algorithms, from which I improved my comprehensive application ability and professional quality.</p>\n<p>我最喜欢的课程是数据结构。数据结构能够让我们了解计算机处理对象的特性，将实际问题中所涉及的处理对象在计算机中表示出来并对它们进行处理。与此同时，我还学习了很多常用的算法，从中提高了综合应用能力和专业素质。</p>\n<h1 id=\"what-is-artificial-intelligence什么是人工智能\"><a class=\"markdownIt-Anchor\" href=\"#what-is-artificial-intelligence什么是人工智能\">#</a> What is Artificial Intelligence 什么是人工智能</h1>\n<p>Artificial intelligence is a branch of computer science that attempts to understand the nature of intelligence and produce new kinds of intelligent machines that can react in a similar way to human intelligence. The main goal is to make machines capable of complex tasks that would normally require human intelligence.</p>\n<p>人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器。其主要目标是使机器能够胜任一些通常需要人类智能才能完成的复杂工作</p>\n<h1 id=\"difference-between-recursion-and-iteration\"><a class=\"markdownIt-Anchor\" href=\"#difference-between-recursion-and-iteration\">#</a> Difference between recursion and iteration</h1>\n<p>Recursion is the program calling itself</p>\n<p>Iteration is to make use of the known variable value and get the new variable value according to the recursion formula</p>\n<p>递归就是指程序调用自身</p>\n<p>迭代是利用已知的变量值，根据递推公式不断演进得到变量新值</p>\n<h1 id=\"也会找英语小短文看过之后翻译\"><a class=\"markdownIt-Anchor\" href=\"#也会找英语小短文看过之后翻译\">#</a> 也会找英语小短文，看过之后翻译</h1>\n",
            "tags": [
                "XXX"
            ]
        },
        {
            "id": "https://haibara567.github.io/2023/03/08/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/",
            "url": "https://haibara567.github.io/2023/03/08/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%A4%8D%E8%AF%95/%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/",
            "title": "项目问题",
            "date_published": "2023-03-08T13:46:25.000Z",
            "content_html": "<h1 id=\"springboot的优势\"><a class=\"markdownIt-Anchor\" href=\"#springboot的优势\">#</a> Springboot 的优势</h1>\n<ul>\n<li>通过简化配置可以快速搭建 Spring 应用程序。</li>\n<li>内嵌 servlet 容器，能够直接使用 java 的 main 方法启动，因此也不需要部署 war 包文件。</li>\n<li>提供 starter 简化 Maven 配置。</li>\n</ul>\n<h1 id=\"有监督学习和无监督学习的区别\"><a class=\"markdownIt-Anchor\" href=\"#有监督学习和无监督学习的区别\">#</a> 有监督学习和无监督学习的区别</h1>\n<p>有监督：通过已有的训练样本（即已知数据及其对应的输出）去训练得到一个最优模型</p>\n<p>无监督：由输入数据中学到或建立一个模型，并依此模式推测新的结果。输入数据没有被标记，也没有确定的结果。</p>\n",
            "tags": [
                "XXX"
            ]
        }
    ]
}